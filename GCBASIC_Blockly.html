<!DOCTYPE html>
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/blockly@10.4.3/blockly.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <style>
        #webpageconsole, #WebPageErrors {
            width: 400px;
            height: 200px;
            min-width: 200px;
            min-height: 100px;
            border: 1px solid black;
            background: #f4f4f4;
            padding: 10px;
            font-family: monospace;
            overflow-y: auto;
            margin: 10px;
            position: relative;
            resize: both;
            white-space: pre-wrap;
            user-select: text;
        }

        #webpageconsole-header, #WebPageErrors-header {
            background: #ddd;
            padding: 5px;
            font-weight: bold;
            margin: 10px 10px 0 10px;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

            #webpageconsole-header button, #WebPageErrors-header button {
                padding: 2px 8px;
                font-size: 12px;
                cursor: pointer;
                margin-left: 5px;
            }

                #webpageconsole-header button.copied {
                    background-color: #4CAF50;
                    color: white;
                }

                #webpageconsole-header button.error {
                    background-color: #f44336;
                    color: white;
                }

        #consoleContainer {
            display: flex;
            flex-wrap: wrap;
            justify-content: flex-start;
            margin-top: 10px;
        }

        #blocklyDiv {
            margin-bottom: 10px;
            resize: both;
            overflow: auto;
            min-width: 200px;
            min-height: 200px;
            color: black;
        }

        .controlButtons {
            margin: 10px 0;
        }

        button {
            margin-right: 10px;
            padding: 5px 10px;
        }

        body {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            margin: 0;
            padding: 10px;
        }

        .content {
            flex: 1;
        }

        .blocklyToolboxDiv {
            background-color: white;
        }

        .blocklyMainBackground {
            fill: #F4F4F4;
        }

        .blocklyMainBackground {
            stroke: black;
            stroke-width: 4px;
        }

        .blocklyWorkspace {
            background-image: none;
        }

        /* Style for black outline around blocks, excluding text */
        .blocklyBlockCanvas .blocklyDraggable > *:not(.blocklyText) {
            stroke: black !important; /* Black outline for all block elements except text */
            stroke-width: 1px !important; /* Visible edge */
        }

        /* Ensure text color and styling remain unaffected */
        .blocklyText {
            stroke: none !important; /* Explicitly remove stroke from text */
            color: inherit !important; /* Preserve original text color */
        }

        /* Hover Effect on Blocks */
        .blocklyDraggable:hover {
            filter: drop-shadow(0px 0px 1px rgb(0, 0, 0));
        }


    </style>
</head>
<body>
    <!-- Header and Title -->
    <div class="content">
        <h1 style="font-size: 12px; font-family: Arial;">BLOCKLY for GCBASIC - build 06152025 18:12</h1>

        <!-- Project Management Controls -->
        <div class="controlButtons">
            <button id="runButton" onclick="runCode()" disabled>Generate Code</button>
            <button onclick="importBlocks()">Import Blocks...</button>
            <button onclick="newProject()">New Project</button>
            <button id="openProjectButton" onclick="openProject()">Open File...</button>
            <button onclick="saveProject()">Save File...</button>
            <button onclick="exportCode()">Export Code</button>
            <button onclick="resetWorkspace()">Reset Workspace</button>
            <button id="toggleGridButton" onclick="toggleGrid()">Toggle Grid (On)</button>
            <button id="openReadmeButton" onclick="showPopupFromReadme()">Open Readme</button>
        </div>

        <!-- Blockly Workspace -->
        <div id="blocklyDiv" style="height: 80vh; width: 100%;"></div>

        <!-- Output Displays -->
        <div id="consoleContainer">
            <div>
                <h3 id="WebPageErrors-header">System Log <button onclick="clearErrors(event)">Clear</button></h3>
                <div id="WebPageErrors"></div>
            </div>
            <div>
                <h3 id="webpageconsole-header">GCBASIC Output <button id="copyConsoleButton" onclick="copyConsole(event)">Copy</button><button onclick="clearConsole(event)">Clear</button></h3>
                <div id="webpageconsole"></div>
            </div>
        </div>
    </div>

<!-- Toolbox Definition -->
<xml id="toolbox" style="display: none">
    <category name="Setup" colour="#FFD700">
        <block type="select_chip"></block>
        <block type="decorative_text"></block>
        <block type="remarks"></block>
    </category>
    <sep></sep>
    <!-- New Constants Category -->
    <category name="Constants" colour="#4CAF50">
        <block type="define_constant"></block>
        <block type="get_numeric_constant"></block>
        <block type="get_port_constant"></block>
        <block type="set_constant_state"></block>
        <block type="constant_block_group"></block>
    </category>
    <sep></sep>
    <category name="Logic" colour="#D1C4E9">
        <block type="controls_if"></block>
        <!-- If-then -->
        <block type="controls_if_else"></block>
        <!-- If-then-else -->
        <block type="logic_compare"></block>
        <!-- Compare -->
        <block type="logic_operation"></block>
        <!-- And/Or -->
        <block type="logic_negate"></block>
        <!-- Not -->
        <block type="logic_boolean"></block>
        <!-- True/False -->
    </category>
    <category name="Math" colour="#2196F3">
        <block type="math_number"></block>
        <block type="math_operation"></block>
        <block type="math_odd_even"></block>
        <block type="math_modulo"></block>
    </category>
    <category name="Variables" colour="#EF9A9A">
        <block type="string_variable"></block>
        <block type="get_variable"></block>
        <block type="set_variable"></block>
    </category>
    <sep></sep>
    <category name="Loops" colour="#A5D6A7">
        <block type="do_loop_simplest"></block>
        <block type="for_next_loop"></block>
        <block type="do_loop_simple"></block>
        <block type="do_loop"></block>
        <block type="repeat_loop_simple"></block>
        <block type="repeat_loop"></block>
    </category>
    <category name="Text" colour="#FFCA28">
        <block type="print_text"></block>
    </category>
    <category name="Lists" colour="#D4A017">
        <block type="create_list"></block>
        <block type="read_table"></block>
    </category>
    <category name="Subroutines" colour="#D7CCC8">
        <block type="call_subroutine"></block>
        <block type="user_subroutine"></block>
    </category>
    <sep></sep>
    <category name="Commands" colour="200">
        <category name="Wait" colour="200">
            <block type="wait_fixed"></block>
            <!--<block type="wait_conditional"></block>-->
        </category>
        <block type="lcd_cls"></block>
    </category>
    <sep></sep>
    <category name="Containers" colour="#64B5F6">
        <block type="variable_block_group"></block>
        <block type="code_container"></block>
    </category>
    <sep></sep>
    <!--<category name="Tools" colour="#FFD700">
        <block type="picture_block"></block>
    </category>-->
</xml>

    <!-- Hidden File Input for Import -->
    <input type="file" id="fileInput" style="display: none">

    <!-- Main Script -->
    <script>
        var workspace;
        var indentationStack = [1];
        let previousName = {};
        let gridVisible = true; // Track grid visibility state

        // Define a table of excluded block types used in RunCode and other functions
        const excludedBlockTypes = [
            'select_chip',
            'numeric_variable',
            'define_constant',
            'variable_block_group',
            'constant_block_group',
            'user_subroutine',
            'create_list'
        ];


    
    // Updated get_port_constant block
    Blockly.Blocks['get_port_constant'] = {
        init: function () {
            this.appendDummyInput()
                .appendField(new Blockly.FieldDropdown(() => this.getPortConstants(), null, { rename: false }), "CONSTANT_NAME");
            this.setColour(160);
            this.setOutput(true, null); // Changed to null for broader compatibility
            this.setTooltip("Gets the state (0 or 1) of a port-related constant (e.g., PORTB.0, PIN1, RA0, RB1) defined by a Configuration Constant block.");
            this.setOnChange(this.validateConstant);
        },

        getPortConstants: function () {
            const PORT_PREFIXES = ['PORT', 'PIN', 'RA', 'RB'];
            let workspace = Blockly.getMainWorkspace();
            if (!workspace) {
                return [["No port constants defined", ""]];
            }
            let constantBlocks = workspace.getBlocksByType("define_constant", false);
            let constantNames = constantBlocks
                .filter(block => {
                    let value = block.getFieldValue("VALUE")?.trim().toUpperCase();
                    return value && PORT_PREFIXES.some(prefix => value.startsWith(prefix));
                })
                .map(block => {
                    let name = block.getFieldValue("NAME").toUpperCase().trim();
                    return [name, name];
                });
            return constantNames.length > 0 ? constantNames : [["No port constants defined", ""]];
        },

        validateConstant: function () {
            const PORT_PREFIXES = ['PORT', 'PIN', 'RA', 'RB'];
            let workspace = Blockly.getMainWorkspace();
            if (!workspace) return;
            let constantName = this.getFieldValue("CONSTANT_NAME");
            let validConstants = workspace.getBlocksByType("define_constant", false)
                .filter(block => {
                    let value = block.getFieldValue("VALUE")?.trim().toUpperCase();
                    return value && PORT_PREFIXES.some(prefix => value.startsWith(prefix));
                })
                .map(block => block.getFieldValue("NAME").toUpperCase().trim());

            if (!validConstants.includes(constantName) && constantName !== "") {
                this.setWarningText("Error: Selected port constant does not exist!", "CONSTANT_MISSING");
                this.setColour("#FF0000");
                if (validConstants.length > 0) {
                    this.setFieldValue(validConstants[0], "CONSTANT_NAME");
                }
            } else {
                this.setWarningText(null);
                this.setColour(160);
            }
        }
    };
    
    // JavaScript code generator for get_port_constant
    Blockly.JavaScript.forBlock['get_port_constant'] = function (block) {
        const PORT_PREFIXES = ['PORT', 'PIN', 'RA', 'RB'];
        let constantName = block.getFieldValue("CONSTANT_NAME");
        let workspace = Blockly.getMainWorkspace();
        let constantBlocks = workspace.getBlocksByType("define_constant", false);
        let constantBlock = constantBlocks.find(b => b.getFieldValue("NAME").toUpperCase().trim() === constantName);

        if (!constantBlock) {
            logToWebPageErrors(`Error: Port constant "${constantName}" not found.\n`, "ERROR");
            return ['0', Blockly.JavaScript.ORDER_ATOMIC];
        }

        let constantValue = constantBlock.getFieldValue("VALUE").trim().toUpperCase();
        if (!PORT_PREFIXES.some(prefix => constantValue.startsWith(prefix))) {
            logToWebPageErrors(`Error: Constant "${constantName}" value "${constantValue}" is not a valid port constant.\n`, "ERROR");
            return ['0', Blockly.JavaScript.ORDER_ATOMIC];
        }

        // Outputs the constant name, which represents the port state (0 or 1)
        return [constantName, Blockly.JavaScript.ORDER_ATOMIC];
    };


    Blockly.Blocks['get_numeric_constant'] = {
    init: function () {
        this.appendDummyInput()
            .appendField(new Blockly.FieldDropdown(() => this.getNumericConstants(), null, { rename: false }), "CONSTANT_NAME");
        this.setColour(160);
        this.setOutput(true, null);
        this.setTooltip("Gets a numeric constant (decimal, hex, or binary) defined by a Configuration Constant block.");
        this.setOnChange(this.validateConstant);
    },

    getNumericConstants: function () {
        let workspace = Blockly.getMainWorkspace();
        if (!workspace) {
            return [["No numeric constants defined", ""]];
        }
        let constantBlocks = workspace.getBlocksByType("define_constant", false);
        let constantNames = constantBlocks
            .filter(block => {
                let value = block.getFieldValue("VALUE")?.trim();
                return value && value.match(/^(?:\d+|(0x|0X)[0-9A-Fa-f]+|(0b|0B)[01]+)$/i);
            })
            .map(block => {
                let name = block.getFieldValue("NAME").toUpperCase().trim();
                return [name, name];
            });
        return constantNames.length > 0 ? constantNames : [["No numeric constants defined", ""]];
    },

    validateConstant: function () {
        let workspace = Blockly.getMainWorkspace();
        if (!workspace) return;
        let constantName = this.getFieldValue("CONSTANT_NAME");
        let validConstants = workspace.getBlocksByType("define_constant", false)
            .filter(block => {
                let value = block.getFieldValue("VALUE")?.trim();
                return value && value.match(/^(?:\d+|(0x|0X)[0-9A-Fa-f]+|(0b|0B)[01]+)$/i);
            })
            .map(block => block.getFieldValue("NAME").toUpperCase().trim());

        if (!validConstants.includes(constantName) && constantName !== "") {
            this.setWarningText("Error: Selected numeric constant does not exist!", "CONSTANT_MISSING");
            this.setColour("#FF0000");
            if (validConstants.length > 0) {
                this.setFieldValue(validConstants[0], "CONSTANT_NAME");
            }
        } else {
            this.setWarningText(null);
            this.setColour(160);
        }
    },

    forceSetValue: function (value) {
        let field = this.getField("CONSTANT_NAME");
        if (field) {
            let originalMenuGenerator = field.menuGenerator_;
            field.menuGenerator_ = [[value, value]];
            try {
                field.setValue(value);
            } finally {
                field.menuGenerator_ = originalMenuGenerator;
            }
        }
    }
};

    // JavaScript code generator for get_numeric_constant
    Blockly.JavaScript.forBlock['get_numeric_constant'] = function (block) {
        let constantName = block.getFieldValue("CONSTANT_NAME");
        let workspace = Blockly.getMainWorkspace();
        let constantBlocks = workspace.getBlocksByType("define_constant", false);
        let constantBlock = constantBlocks.find(b => b.getFieldValue("NAME").toUpperCase().trim() === constantName);

        if (!constantBlock) {
            logToWebPageErrors(`Error: Numeric constant "${constantName}" not found.\n`, "ERROR");
            return ['0', Blockly.JavaScript.ORDER_ATOMIC];
        }

        let constantValue = constantBlock.getFieldValue("VALUE").trim();
        if (!constantValue.match(/^(?:\d+|(0x|0X)[0-9A-Fa-f]+|(0b|0B)[01]+)$/i)) {
            logToWebPageErrors(`Error: Constant "${constantName}" value "${constantValue}" is not a valid numeric value.\n`, "ERROR");
            return ['0', Blockly.JavaScript.ORDER_ATOMIC];
        }

        return [constantName, Blockly.JavaScript.ORDER_ATOMIC];
    };



    // Revised set_constant_state block
    Blockly.Blocks['set_constant_state'] = {
        init: function () {
            this.appendDummyInput()
                .appendField("Set Constant")
                .appendField(new Blockly.FieldDropdown(() => this.getConstantNames(), this.onDropdownChange.bind(this)), "CONSTANT_NAME")
                .appendField("to")
                .appendField(new Blockly.FieldDropdown([["ON", "1"], ["OFF", "0"]]), "STATE");
            this.setPreviousStatement(true, null);
            this.setNextStatement(true, null);
            this.setColour(160);
            this.setTooltip("Sets an existing constant (e.g., TRIG) to ON (1) or OFF (0). Outputs code like PORTB.0 = 1 or PORTB.0 = 0. Excludes numeric constants.");
            this.setHelpUrl("");
            this.isLoading = false;
            this.setOnChange(this.validateConstant);
        },

        getConstantNames: function () {
            let workspace = Blockly.getMainWorkspace();
            if (!workspace) {
                return [["No constants defined", ""]];
            }
            let constantBlocks = workspace.getBlocksByType("define_constant", false);
            let constantNames = constantBlocks
                .filter(block => {
                    let value = block.getFieldValue("VALUE")?.trim();
                    return value && !value.match(/^(?:\d+|(0x|0X)[0-9A-Fa-f]+|(0b|0B)[01]+)$/i);
                })
                .map(block => {
                    let name = block.getFieldValue("NAME").toUpperCase().trim();
                    return [name, name];
                });
            return constantNames.length > 0 ? constantNames : [["No constants defined", ""]];
        },

        onDropdownChange: function (newValue) {
            if (!this.isLoading) {
                this.validateConstant();
            }
            return newValue;
        },

        forceSetValue: function (value) {
            let field = this.getField("CONSTANT_NAME");
            if (field) {
                let originalMenuGenerator = field.menuGenerator_;
                field.menuGenerator_ = [[value, value]];
                try {
                    field.setValue(value);
                } finally {
                    field.menuGenerator_ = originalMenuGenerator;
                }
            }
        },

        validateConstant: function () {
            if (this.isLoading) return;
            let workspace = Blockly.getMainWorkspace();
            if (!workspace) return;
            let constantName = this.getFieldValue("CONSTANT_NAME");
            let validConstants = workspace.getBlocksByType("define_constant", false)
                .filter(block => {
                    let value = block.getFieldValue("VALUE")?.trim();
                    return value && !value.match(/^(?:\d+|(0x|0X)[0-9A-Fa-f]+|(0b|0B)[01]+)$/i);
                })
                .map(block => block.getFieldValue("NAME").toUpperCase().trim());

            if (!validConstants.includes(constantName) && constantName !== "") {
                this.setWarningText("Error: Selected constant does not exist or is numeric!", "CONSTANT_MISSING");
                this.setColour("#FF0000");
                if (validConstants.length > 0) {
                    this.setFieldValue(validConstants[0], "CONSTANT_NAME");
                } else {
                    this.setFieldValue("", "CONSTANT_NAME");
                }
            } else {
                this.setWarningText(null);
                this.setColour(160);
            }
        }
    };



    // JavaScript code generator for set_constant_state
    Blockly.JavaScript.forBlock['set_constant_state'] = function (block) {
        let constantName = block.getFieldValue("CONSTANT_NAME");
        let state = block.getFieldValue("STATE"); // 1 for ON, 0 for OFF
        let workspace = Blockly.getMainWorkspace();
        let constantBlocks = workspace.getBlocksByType("define_constant", false);
        let constantBlock = constantBlocks.find(b => b.getFieldValue("NAME").toUpperCase().trim() === constantName);

        if (!constantBlock) {
            logToWebPageErrors(`Error: Constant "${constantName}" not found for set operation.\n`, "ERROR");
            return tab() + `// Error: Constant "${constantName}" not defined\n`;
        }

        let constantValue = constantBlock.getFieldValue("VALUE").trim();
        // Validate that the constant value resembles a port pin (e.g., PORTB.0)
        if (!constantValue.match(/^[A-Z]+\.\d+$/i)) {
            logToWebPageErrors(`Error: Constant "${constantName}" value "${constantValue}" is not a valid port pin (e.g., PORTB.0).\n`, "ERROR");
            return tab() + `// Error: Invalid port pin "${constantValue}" for constant "${constantName}"\n`;
        }

        let code = tab() + `${constantValue} = ${state}\n`;
        return formatComment(block, code, indentationStack);
    };

        // Block definition for picture_block with minimal border and maximized picture
        Blockly.Blocks['picture_block'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage("https://via.placeholder.com/50", 400, 400, "Click to upload or drag image here"), "IMAGE");

                this.setColour("#64B5F6");
                this.setTooltip("Click to upload an image or drag an image file here.");
                this.setHelpUrl("");

                this.setPreviousStatement(true, null); // Allow connection above
                this.setNextStatement(true, null); // Allow connection below

                this.setupImageUpload();
                this.setupDragAndDrop();
            },

            setupImageUpload: function () {
                let imageField = this.getField("IMAGE");
                imageField.clickHandler_ = function () {
                    let input = document.createElement("input");
                    input.type = "file";
                    input.accept = "image/*";

                    input.onchange = function (event) {
                        let file = event.target.files[0];
                        let reader = new FileReader();

                        reader.onload = function () {
                            imageField.setValue(reader.result); // Convert image to Base64 and store it
                        };

                        if (file) {
                            reader.readAsDataURL(file);
                        }
                    };

                    input.click();
                };
            },

            setupDragAndDrop: function () {
                const block = this;
                const workspace = block.workspace;

                // Wait for the block to be rendered
                setTimeout(() => {
                    const svgGroup = block.getSvgRoot();
                    if (!svgGroup) return;

                    // Add drag-and-drop event listeners
                    svgGroup.addEventListener('dragover', (event) => {
                        event.preventDefault(); // Prevent default to allow drop
                    });

                    svgGroup.addEventListener('dragenter', (event) => {
                        event.preventDefault();
                        svgGroup.style.border = '1px dashed #000'; // Minimal border feedback
                    });

                    svgGroup.addEventListener('dragleave', (event) => {
                        event.preventDefault();
                        svgGroup.style.border = ''; // Remove feedback
                    });

                    svgGroup.addEventListener('drop', (event) => {
                        event.preventDefault();
                        svgGroup.style.border = ''; // Remove feedback

                        const files = event.dataTransfer.files;
                        if (files && files.length > 0) {
                            const file = files[0];
                            if (file.type.startsWith('image/')) {
                                const reader = new FileReader();
                                reader.onload = function () {
                                    const imageField = block.getField("IMAGE");
                                    imageField.setValue(reader.result); // Update image with Base64
                                };
                                reader.readAsDataURL(file);
                            } else {
                                logToWebPageErrors("Error: Dropped file is not an image.\n", "ERROR");
                            }
                        }
                    });
                }, 0); // Use setTimeout to ensure SVG is rendered
            }
        };

        // JavaScript Code Generator (No execution needed)
        Blockly.JavaScript['picture_block'] = function (block) {
            return ''; // No actual code needed
        };


        Blockly.Blocks['code_container'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("Snippet");

                // Add a text input field for comments
                this.appendDummyInput()
                    .appendField(new Blockly.FieldTextInput("Enter comment here"), "COMMENT");

                // This input allows multiple blocks to be dropped inside
                this.appendStatementInput("STACK")
                    .setCheck(null) // Accept any type of blocks
                    .setAlign(Blockly.ALIGN_RIGHT);

                this.setColour("#808080");
                this.setTooltip("A collapsible container block that accepts multiple blocks and includes a comment field.");
                this.setHelpUrl("");

                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
            }
        };



        // JavaScript code generator for code_container
        Blockly.JavaScript.forBlock['code_container'] = function (block) {
            let code = "";

            // Handle the comment
            const text = block.getFieldValue("COMMENT") || "";
            const lines = (text.trim() === "" || text.trim() === "Enter comment here" ? ["Snippet Code Container"] : text.split("\n").filter(line => line.trim() !== "")); // Default to "Snippet Code Container" if empty or default text

            if (lines.length > 0) {
                const originalIndentLevel = indentationStack[indentationStack.length - 1] || 0;
                const commentIndentLevel = originalIndentLevel;

                lines.forEach(line => {
                    code += reformatCode(`// ${line.trim()}`, commentIndentLevel) + "\n";
                });
            }

            // Extract and process blocks within the STACK input
            const stackInput = block.getInput("STACK");
            if (stackInput && stackInput.connection) {
                const nestedBlocks = Blockly.JavaScript.statementToCode(block, "STACK");

                if (nestedBlocks) {
                    // Parse the nested code to filter out excluded blocks
                    const linesOfCode = nestedBlocks.split("\n").filter(line => line.trim() !== "");
                    let filteredCode = "";

                    // Process all child blocks in the chain
                    const childBlocks = [];
                    let currentChild = stackInput.connection.targetBlock();
                    while (currentChild) {
                        childBlocks.push(currentChild);
                        currentChild = currentChild.getNextBlock();
                    }

                    childBlocks.forEach(childBlock => {
                        const childType = childBlock.type;
                        if (!excludedBlockTypes.includes(childType) && Blockly.JavaScript.forBlock[childType]) {
                            const childCode = Blockly.JavaScript.forBlock[childType](childBlock);
                            if (childCode && childCode.trim() && !childCode.trim().startsWith("' No code provided")) {
                                filteredCode += childCode.trim() + "\n";
                            }
                        }
                    });

                    if (filteredCode) {
                        const originalIndentLevel = indentationStack[indentationStack.length - 1] || 0;
                        const bodyIndentLevel = originalIndentLevel + 1; // Indent nested code one level deeper

                        // Temporarily set the indentation level for nested code
                        indentationStack[indentationStack.length - 1] = bodyIndentLevel;
                        const indentedLines = filteredCode.split("\n").filter(line => line.trim() && !line.trim().startsWith("' No code provided"));
                        const indentedCode = indentedLines.map(line => reformatCode(line, bodyIndentLevel)).join("\n");
                        code += indentedCode + "\n";

                        // Restore the original indentation level
                        indentationStack[indentationStack.length - 1] = originalIndentLevel;
                    }
                }
            }

            return code; // Return the combined comment and filtered nested code
        };

        Blockly.Blocks['decorative_text'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldMultilineInput("Decorative text block "), "TEXT");

                this.setColour("#808080"); // Gray color for decoration
                this.setTooltip("A decorative text block for annotations or labels.");
                this.setHelpUrl(""); // No help URL needed
                this.setMovable(true);
                this.setDeletable(true);

                // Ensuring proper block behavior
                this.setOutput(false); // Doesn't output a value
                this.setPreviousStatement(false); // Allows connecting to a previous block
                this.setNextStatement(false); // No chaining with next blocks
            }
        };

        // Code generator for JavaScript (returns empty string)
        Blockly.JavaScript.forBlock['decorative_text'] = function (block) {
            return ''; // No code generation required for decorative text
        };

        Blockly.Blocks['remarks'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldMultilineInput("Remark text block "), "TEXT");

                this.setColour("#808080"); // Gray color for decoration
                this.setTooltip("A decorative text block for remarks.");
                this.setHelpUrl(""); // No help URL needed
                this.setMovable(true);
                this.setDeletable(true);

                // Ensuring proper block behavior
                this.setOutput(false); // Doesn't output a value
                this.setPreviousStatement(true); // Allows connecting to a previous block
                this.setNextStatement(true); // Allows chaining with next blocks
            }
        };


        // JavaScript code generator for decorative_text block with indentation management
        Blockly.JavaScript.forBlock['remarks'] = function (block) {
            const text = block.getFieldValue("TEXT") || "Add Text Here";
            const lines = text.split("\n").filter(line => line.trim() !== ""); // Split into lines, remove empty lines
            let code = "";

            if (lines.length > 0) {
                // Cache the current indentation level
                const originalIndentLevel = indentationStack[indentationStack.length - 1] || 0;
                // Maintain the current indentation level for comments
                const commentIndentLevel = originalIndentLevel; // Use the block's current nesting level

                lines.forEach(line => {
                    code += reformatCode(`// ${line.trim()}`, commentIndentLevel) + "\n";
                });
            }

            return code; // Return the formatted comment block
        };

        Blockly.Blocks['read_table'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("ReadTable")
                    .appendField(new Blockly.FieldDropdown(() => this.getTableNames()), "TABLE_NAME");

                this.appendValueInput("ITEM")
                    .setCheck("Number")
                    .appendField("Item");

                this.appendValueInput("OUTPUT")
                    .setCheck("Variable")
                    .appendField("Output");

                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#D4A017");
                this.setTooltip("Reads an item from a lookup table and stores the result in a variable.");
                this.setInputsInline(true);
            },

            getTableNames: function () {
                let workspace = Blockly.getMainWorkspace();
                let listBlocks = workspace.getBlocksByType("create_list", false);
                let tableNames = listBlocks.map(block => [block.getFieldValue("LIST_NAME"), block.getFieldValue("LIST_NAME")]);

                return tableNames.length > 0 ? tableNames : [["No tables found", ""]];
            },

            onchange: function () {
                let workspace = Blockly.getMainWorkspace();
                let tableName = this.getFieldValue("TABLE_NAME");
                let validTables = workspace.getBlocksByType("create_list", false).map(block => block.getFieldValue("LIST_NAME"));

                if (!validTables.includes(tableName)) {
                    this.setWarningText("Error: Referenced table does not exist!", "TABLE_MISSING");
                    this.setColour("#FF0000");
                } else {
                    this.setWarningText(null);
                    this.setColour("#D4A017");
                }
            }
        };

        // JavaScript Code Generator
        Blockly.JavaScript.forBlock['read_table'] = function (block) {
            let tableName = block.getFieldValue("TABLE_NAME");
            let item = Blockly.JavaScript.valueToCode(block, 'ITEM', Blockly.JavaScript.ORDER_ATOMIC) || '0';
            let output = Blockly.JavaScript.valueToCode(block, 'OUTPUT', Blockly.JavaScript.ORDER_ATOMIC) || 'null';

            let code = tab() + `ReadTable ${tableName}, ${item}, ${output}\n`;
            return code;
        };



        Blockly.Blocks['create_list'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("Table")
                    .appendField(new Blockly.FieldTextInput("myList", this.validateListName.bind(this)), "LIST_NAME"); // Unique list name field with validation

                this.itemCount_ = 3; // Default visible item count
                this.maxItems_ = 50; // Set fixed item limit

                this.createHiddenItems(); // Ensures only 3 items show initially
                this.addItemsDropdown();

                this.setColour(`#D4A017`);
                this.setTooltip("Creates a named list dynamically.");
                this.setInputsInline(false);
            },

            validateListName: function (newName) {
                if (!newName || newName.trim() === "") {
                    return "myList"; // Default if empty
                }

                let baseName = newName.trim();
                let workspace = this.workspace;
                let existingNames = workspace.getAllBlocks()
                    .filter(block => block.type === "create_list" && block !== this)
                    .map(block => block.getFieldValue("LIST_NAME") || "")
                    .filter(name => name.trim() !== "");

                let uniqueName = baseName;
                let counter = 1;
                while (existingNames.includes(uniqueName)) {
                    uniqueName = `${baseName}${counter}`;
                    counter++;
                }

                return uniqueName;
            },

            createHiddenItems: function () {
                for (let i = 0; i < this.maxItems_; i++) {
                    let newInput = this.appendValueInput("ITEM" + i)
                        .setCheck(null)
                        .appendField("item " + (i + 1))
                        .setAlign(Blockly.ALIGN_RIGHT);

                    if (i >= this.itemCount_) {
                        newInput.setVisible(false); // Hide all items beyond the first 3
                    }
                }
            },

            mutationToDom: function () {
                let container = Blockly.utils.xml.createElement("mutation");
                container.setAttribute("items", this.itemCount_);
                container.setAttribute("list_name", this.getFieldValue("LIST_NAME") || "myList"); // Store the unique name
                return container;
            },

            domToMutation: function (xmlElement) {
                let itemCount = parseInt(xmlElement.getAttribute("items"), 10);
                let savedName = xmlElement.getAttribute("list_name") || "myList";
                if (!isNaN(itemCount)) {
                    this.itemCount_ = this.maxItems_; // Load all items first

                    // Purge NULL items starting from item 50 downward
                    for (let i = this.maxItems_ - 1; i >= 0; i--) {
                        let itemField = this.getInputTargetBlock("ITEM" + i);
                        let input = this.getInput("ITEM" + i);
                        if (!itemField || Blockly.JavaScript.valueToCode(this, "ITEM" + i, Blockly.JavaScript.ORDER_ATOMIC) === "null") {
                            input.setVisible(false);
                        } else {
                            this.itemCount_ = i + 1; // Adjust item count based on last valid entry
                        }
                    }
                }

                // Set the saved name, re-validating for uniqueness if needed
                this.setFieldValue(this.validateListName(savedName), "LIST_NAME");
                this.rebuildItems();
                this.setCollapsed(true); // Collapse the block on restore
            },

            rebuildItems: function () {
                for (let i = 0; i < this.maxItems_; i++) {
                    let input = this.getInput("ITEM" + i);
                    if (input) input.setVisible(i < this.itemCount_); // Show only active items
                }
            },

            addItemsDropdown: function () {
                if (this.getInput("ADD_ITEMS")) {
                    this.removeInput("ADD_ITEMS");
                }

                this.appendDummyInput("ADD_ITEMS")
                    .appendField("add items")
                    .appendField(new Blockly.FieldDropdown([
                        ["+1", "1"],
                        ["+2", "2"],
                        ["+3", "3"]
                    ]), "ADD_COUNT");
            },

            onchange: function (event) {
                if (event.type === Blockly.Events.BLOCK_CHANGE) {
                    let selectedCount = parseInt(this.getFieldValue("ADD_COUNT"), 10);

                    if (!isNaN(selectedCount)) {
                        let newItemCount = this.itemCount_ + selectedCount;
                        if (newItemCount > this.maxItems_) newItemCount = this.maxItems_;

                        for (let i = this.itemCount_; i < newItemCount; i++) {
                            let input = this.getInput("ITEM" + i);
                            if (input) input.setVisible(true); // Reveal hidden inputs instead of creating new ones
                        }

                        this.itemCount_ = newItemCount;
                        this.render(); // Refresh display
                    }
                }
            }
        };

        //Blockly.Blocks['create_list'] = {
        //    init: function () {
        //        this.appendDummyInput()
        //            .appendField("create list")
        //            .appendField(new Blockly.FieldTextInput("myList"), "LIST_NAME"); // Unique list name field

        //        this.itemCount_ = 2; // Default item count
        //        this.previousAddCount = "0"; // Prevent auto-adding errors

        //        this.rebuildItems();
        //        this.addItemsDropdown();

        //        this.setColour(`#4DB6AC`);
        //        this.setTooltip("Creates a named list dynamically.");
        //        this.setInputsInline(false); // Ensure stacked layout
        //    },

        //    // Ensure XML saves item count for consistent restoration
        //    mutationToDom: function () {
        //        let container = Blockly.utils.xml.createElement("mutation");
        //        container.setAttribute("items", this.itemCount_);
        //        return container;
        //    },

        //    domToMutation: function (xmlElement) {
        //        let itemCount = parseInt(xmlElement.getAttribute("items"), 10);
        //        if (!isNaN(itemCount)) {
        //            this.itemCount_ = itemCount;
        //            this.rebuildItems(); // Restore correct number of items
        //        }
        //    },

        //    rebuildItems: function () {
        //        let existingConnections = {};
        //        for (let i = 0; i < this.itemCount_; i++) {
        //            let input = this.getInput("ITEM" + i);
        //            if (input && input.connection && input.connection.targetConnection) {
        //                existingConnections[i] = input.connection.targetConnection;
        //            }
        //        }

        //        let inputNames = this.inputList.map(input => input.name);
        //        for (let name of inputNames) {
        //            if (name.startsWith("ITEM")) {
        //                this.removeInput(name);
        //            }
        //        }

        //        for (let i = 0; i < this.itemCount_; i++) {
        //            let newInput = this.appendValueInput("ITEM" + i)
        //                .setCheck(null)
        //                .appendField("item " + (i + 1))
        //                .setAlign(Blockly.ALIGN_RIGHT);

        //            if (existingConnections[i]) {
        //                newInput.connection.connect(existingConnections[i]);
        //            }
        //        }
        //    },

        //    addItemsDropdown: function () {
        //        if (this.getInput("ADD_ITEMS")) {
        //            this.removeInput("ADD_ITEMS");
        //        }

        //        this.appendDummyInput("ADD_ITEMS")
        //            .appendField("add items")
        //            .appendField(new Blockly.FieldDropdown([
        //                ["+1", "1"],
        //                ["+2", "2"],
        //                ["+3", "3"]
        //            ]), "ADD_COUNT");

        //        setTimeout(() => {
        //            this.getField("ADD_COUNT").setValue("1");
        //        }, 50);
        //    },

        //    onchange: function (event) {
        //        if (event.type === Blockly.Events.BLOCK_CHANGE) {
        //            let selectedCount = this.getFieldValue("ADD_COUNT");

        //            if (selectedCount !== this.previousAddCount) {
        //                let addCount = parseInt(selectedCount, 10);
        //                this.itemCount_ += addCount;
        //                this.previousAddCount = selectedCount;

        //                this.rebuildItems();
        //                this.addItemsDropdown();
        //                this.render();
        //            }
        //        }
        //    }
        //};



        //Blockly.Blocks['create_list'] = {
        //    init: function () {
        //        this.appendDummyInput()
        //            .appendField("create list")
        //            .appendField(new Blockly.FieldTextInput("myList"), "LIST_NAME"); // List name field

        //        // Default item count
        //        this.itemCount_ = 2;

        //        for (let i = 0; i < this.itemCount_; i++) {
        //            this.appendValueInput("ITEM" + i)
        //                .setCheck(null)
        //                .appendField("item " + (i + 1))
        //                .setAlign(Blockly.ALIGN_RIGHT); // Aligns inputs for external layout
        //        }

        //        // Add items dropdown always positioned last
        //        this.addItemsDropdown();

        //        this.setColour(`#4DB6AC`);
        //        this.setTooltip("Creates a named list dynamically.");
        //        this.setInputsInline(false); // Ensure inputs are external
        //    },

        //    addItemsDropdown: function () {
        //        if (this.getInput("ADD_ITEMS")) {
        //            this.removeInput("ADD_ITEMS"); // Remove previous dropdown
        //        }

        //        this.appendDummyInput("ADD_ITEMS")
        //            .appendField("add items")
        //            .appendField(new Blockly.FieldDropdown([
        //                ["+1", "1"],
        //                ["+2", "2"],
        //                ["+3", "3"]
        //            ]), "ADD_COUNT");

        //        // Ensure dropdown has a valid default selection
        //        setTimeout(() => {
        //            this.getField("ADD_COUNT").setValue("1");
        //        }, 50);
        //    },

        //    onchange: function (event) {
        //        if (event.type === Blockly.Events.BLOCK_CHANGE) {
        //            let addCount = parseInt(this.getFieldValue("ADD_COUNT"), 10);

        //            if (!isNaN(addCount)) {
        //                for (let i = 0; i < addCount; i++) {
        //                    this.itemCount_++;
        //                    this.appendValueInput("ITEM" + (this.itemCount_ - 1))
        //                        .setCheck(null)
        //                        .appendField("item " + this.itemCount_)
        //                        .setAlign(Blockly.ALIGN_RIGHT); // Keep new inputs aligned externally
        //                }

        //                this.addItemsDropdown(); // Ensure dropdown stays last
        //                this.render(); // Refresh display
        //            }
        //        }
        //    }
        //};




        Blockly.JavaScript.forBlock['create_list'] = function (block) {
            let listName = block.getFieldValue("LIST_NAME"); // Get list name
            let items = [];

            for (let i = 0; i < block.itemCount_; i++) {
                let item = Blockly.JavaScript.valueToCode(block, 'ITEM' + i, Blockly.JavaScript.ORDER_ATOMIC) || 'null';
                items.push(item);
            }

            // Remove trailing null values recursively
            while (items.length > 0 && items[items.length - 1] === 'null') {
                items.pop();
            }

            // Replace null with 0 for remaining items
            const cleanedItems = items.map(item => item === 'null' ? '0' : item);

            // Cache the current indentation level
            const originalIndentLevel = indentationStack[indentationStack.length - 1] || 0;
            indentationStack[indentationStack.length - 1] = 0; // Set to 0 for Table line

            let code = `\n${tab()}Table ${listName}\n`; // Table line with comment, no extra newline

            // Set body indentation to a fixed one-level indent (1 tab)
            const bodyIndentLevel = 1; // Fixed to one level, ignoring originalIndentLevel
            cleanedItems.forEach((item, index) => {
                code += reformatCode(item, bodyIndentLevel); // No newline after each item
                if (index < cleanedItems.length - 1) code += '\n'; // Add newline only between items
            });
            code += '\n' + reformatCode('End Table\n', bodyIndentLevel); // Add newline before End Table

            // Restore original indentation level
            indentationStack[indentationStack.length - 1] = originalIndentLevel;

            return code; // Must return a string for statement blocks
        };


        // User-Definable Function Block

        // User-Definable Function Block (Standalone)
        //Blockly.Blocks['call_subroutine'] = {
        //    init: function () {
        //        this.appendDummyInput()
        //            .appendField(new Blockly.FieldImage("https://www.gstatic.com/codesite/ph/images/star.gif", 16, 16, "*", true)) // Star help icon
        //            .appendField(new Blockly.FieldTextInput("to do something"), "FUNCTION_NAME"); // Customizable function name
        //        this.appendValueInput("INPUT")
        //            .setCheck("Number")
        //            .appendField("Input");
        //        this.appendStatementInput("BODY")
        //            .setCheck(null)
        //            .appendField("Do");
        //        this.setPreviousStatement(true, null); // Allow connection above
        //        this.setNextStatement(true, null); // Allow connection below
        //        this.setColour('#D7CCC8'); // Purple background
        //        this.setStyle('function_style', '#D7CCC8', '#FFC107'); // Purple background, yellow outline
        //        this.setTooltip("Define a custom standalone function with a name, input, and body.");
        //        this.setHelpUrl("https://www.example.com/help/call_subroutine"); // Replace with actual help URL
        //    }
        //};


        Blockly.Blocks['call_subroutine'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("Call Subroutine")
                    .appendField(new Blockly.FieldTextInput(""), "SUB_NAME"); // Allows renaming
                this.appendValueInput("PARAMS")
                    .setCheck("Array")
                    .appendField("optional parameters");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour(`#D7CCC8`);
                this.setTooltip("Calls a custom subroutine dynamically.");
                this.setHelpUrl("https://www.example.com/help/dynamic_function");

                // Initialize color and warning based on current state
                this.setOnChange(function (changeEvent) {
                    let subName = this.getFieldValue("SUB_NAME").trim();
                    let paramsInput = this.getInput('PARAMS');
                    let isParamsConnected = paramsInput && paramsInput.connection.targetConnection;

                    if (!subName && !isParamsConnected) {
                        // Both are empty/disconnected → RED
                        this.setWarningText('Subroutine name must be set or parameters must be connected.');
                        this.setColour('#FF6B6B');
                    } else {
                        // Either has a value or connection → NORMAL
                        this.setWarningText(null);
                        this.setColour('#D7CCC8');
                    }
                });

            }
        };


        //Blockly.Blocks['call_subroutine'] = {
        //    init: function () {
        //        this.appendDummyInput()
        //            .appendField("Call Subroutine")
        //            .appendField(new Blockly.FieldTextInput("subname"), "SUB_NAME"); // Allows renaming
        //        this.appendValueInput("PARAMS")
        //            .setCheck("Array")
        //            .appendField("optional parameters");
        //        this.setPreviousStatement(true, null);
        //        this.setNextStatement(true, null);
        //        this.setColour(`#D7CCC8`);
        //        this.setTooltip("Calls a custom subroutine dynamically.");
        //        this.setHelpUrl("https://www.example.com/help/dynamic_function");
        //    }
        //};

        Blockly.JavaScript.forBlock['call_subroutine'] = function (block) {
            const subName = block.getFieldValue('SUB_NAME') || 'subname';
            const params = Blockly.JavaScript.valueToCode(block, 'PARAMS', Blockly.JavaScript.ORDER_ATOMIC) || '';

            // Check if subName contains both "(" and ")" and params is not present
            if (subName.includes('(') && subName.includes(')') && !params.trim()) {
                // Return subName as-is, including parentheses
                const code = tab() + `${subName}\n`;
                return code;
            }

            // Return as-is with params if present or no parentheses in subName
            const code = tab() + `${subName}(${params})\n`;
            return code;
        };




        Blockly.Blocks['user_subroutine'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("Define Subroutine")
                    .appendField(new Blockly.FieldTextInput("mySubroutine"), "SUB_NAME"); // Allows custom naming
                this.appendValueInput("PARAMS")
                    .setCheck("Array")
                    .appendField("Parameters");
                this.appendStatementInput("BODY");

                this.setInputsInline(true); // Makes parameters inline by default
                this.setColour(`#D7CCC8`);
                this.setTooltip("Defines a reusable subroutine with parameters.");
                this.setHelpUrl("https://www.example.com/help/user_subroutine");
            }
        };


        Blockly.JavaScript.forBlock['user_subroutine'] = function (block) {
            const subName = block.getFieldValue('SUB_NAME') || 'mySubroutine';
            const params = Blockly.JavaScript.valueToCode(block, 'PARAMS', Blockly.JavaScript.ORDER_ATOMIC) || '';
            const body = Blockly.JavaScript.statementToCode(block, 'BODY') || '';

            // Cache the current indentation level
            const originalIndentLevel = indentationStack[indentationStack.length - 1] || 0;
            indentationStack[indentationStack.length - 1] = 0; // Set to 0 for subName

            let code = `\n\nSub ${subName}(${params})\n\n`; // Sub line at position 0

            // Set body indentation to a fixed one-level indent (1 tab)
            const bodyIndentLevel = 1; // Fixed to one level, ignoring originalIndentLevel
            code += reformatCode(body, bodyIndentLevel) + '\n\n'; // Indent body one level

            code += reformatCode(`\nEnd Sub\n`, bodyIndentLevel) + '\n'; // Indent body one level  ;
            // Set back to 0 for End Sub
            indentationStack[indentationStack.length - 1] = 0;

            // Restore original indentation level
            indentationStack[indentationStack.length - 1] = originalIndentLevel;

            return code;
        };

        // For-Next Loop Block

        Blockly.Blocks['for_next_loop'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("For");
                this.appendValueInput("VAR")
                    .setCheck("Variable");
                this.appendDummyInput()
                    .appendField("=");
                this.appendValueInput("START")
                    .setCheck("Number");
                this.appendDummyInput()
                    .appendField("to");
                this.appendValueInput("END")
                    .setCheck("Number");
                this.appendStatementInput("DO");
                this.appendDummyInput()
                    .appendField("Next");
                this.setPreviousStatement(true);
                this.setNextStatement(true);
                this.setColour('#A5D6A7'); // Ensuring consistent hex format
                this.setInputsInline(true);
                this.setTooltip("For loop with a counter variable from start to end."); // Correct function name
                this.setHelpUrl("https://www.example.com/help/for-next");
                this.setOnChange(function (changeEvent) {
                    // Check if VAR input is connected
                    var varInput = this.getInput('VAR');
                    if (varInput && !varInput.connection.isConnected()) {
                        this.setWarningText('Variable input must be connected');
                        this.setColour('#FF6B6B'); // Red color to indicate error
                    } else {
                        this.setWarningText(null);
                        this.setColour('#A5D6A7'); // Original green color
                    }
                });
            }
        };


        Blockly.JavaScript.forBlock['for_next_loop'] = function (block) {
            var currentIndent = indentationStack[indentationStack.length - 1] || 1;
            indentationStack[indentationStack.length - 1] = currentIndent;
            var varName = Blockly.JavaScript.valueToCode(block, 'VAR', Blockly.JavaScript.ORDER_ATOMIC) || 'i'; // Handle block input
            var start = Blockly.JavaScript.valueToCode(block, 'START', Blockly.JavaScript.ORDER_ATOMIC) || '0';
            var end = Blockly.JavaScript.valueToCode(block, 'END', Blockly.JavaScript.ORDER_ATOMIC) || '10';
            var doCode = Blockly.JavaScript.statementToCode(block, 'DO') || '';
            var code = [];
            code.push(tab() + `For ${varName} = ${start} to ${end}`);
            indentationStack[indentationStack.length - 1]++;
            if (doCode.trim()) {
                code.push(reformatCode(doCode, indentationStack[indentationStack.length - 1]));
            } else {
                code.push(tab() + '\' No DO code provided');
            }
            indentationStack[indentationStack.length - 1] = currentIndent;
            code.push(tab() + `Next ${varName}`);
            code = code.join('\n') + '\n';
            return formatComment(block, code, indentationStack);
        };

        Blockly.Blocks['controls_if'] = {
            init: function () {
                this.appendValueInput("CONDITION")
                    .setCheck("Boolean")
                    .appendField("If");

                this.appendStatementInput("DO")
                    .setCheck(null)
                    .appendField("Then");

                this.setColour('#D1C4E9');
                this.setTooltip("If condition is true, execute the statements.");
                this.setHelpUrl("https://www.example.com/help/if-then");

                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
            }
        };


        Blockly.JavaScript.forBlock['controls_if'] = function (block) {
            const condition = Blockly.JavaScript.valueToCode(block, 'CONDITION', Blockly.JavaScript.ORDER_ATOMIC) || 'true';
            const doCode = Blockly.JavaScript.statementToCode(block, 'DO') || '';
            let code = tab() + `If ${condition} Then\n`;

            var currentIndentLevel = indentationStack[indentationStack.length - 1] || 0;
            indentationStack[indentationStack.length - 1] = currentIndentLevel + 1; // Increment tabcounter
            code += reformatCode(doCode, indentationStack[indentationStack.length - 1]) + "\n"; // Re-indent doCode
            indentationStack[indentationStack.length - 1] = currentIndentLevel; // Decrement tabcounter

            code += tab() + `End If\n`;
            return code;
        };


        Blockly.Blocks['controls_if_else'] = {
            init: function () {
                this.appendValueInput("CONDITION")
                    .setCheck("Boolean")
                    .appendField("If");

                this.appendStatementInput("DO")
                    .setCheck(null)
                    .appendField("Then");

                this.appendStatementInput("ELSE")
                    .setCheck(null)
                    .appendField("Else");

                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour('#D1C4E9');
                this.setTooltip("If condition is true, execute the 'Then' statements; otherwise, execute the 'Else' statements.");
                this.setHelpUrl("https://www.example.com/help/if-then-else"); // Replace with actual help URL
            }
        };

        Blockly.JavaScript.forBlock['controls_if_else'] = function (block) {
            const condition = Blockly.JavaScript.valueToCode(block, 'CONDITION', Blockly.JavaScript.ORDER_ATOMIC) || 'true';
            const doCode = Blockly.JavaScript.statementToCode(block, 'DO') || '';
            const elseCode = Blockly.JavaScript.statementToCode(block, 'ELSE') || '';
            let code = tab() + `If ${condition} Then\n`;

            var currentIndentLevel = indentationStack[indentationStack.length - 1] || 0;
            indentationStack[indentationStack.length - 1] = currentIndentLevel + 1; // Increment tabcounter
            code += reformatCode(doCode, indentationStack[indentationStack.length - 1]) + "\n"; // Re-indent doCode
            indentationStack[indentationStack.length - 1] = currentIndentLevel; // Decrement tabcounter

            code += tab() + `Else\n`;
            indentationStack[indentationStack.length - 1] = currentIndentLevel + 1; // Increment tabcounter
            code += reformatCode(elseCode, indentationStack[indentationStack.length - 1]) + "\n"; // Re-indent elseCode
            indentationStack[indentationStack.length - 1] = currentIndentLevel; // Decrement tabcounter
            code += tab() + `End If\n`;
            return code;
        };


        Blockly.Blocks['logic_compare'] = {
            init: function () {
                this.appendValueInput("A")
                    .setCheck("Number");
                this.appendDummyInput()
                    .appendField(new Blockly.FieldDropdown([
                        ["=", "="], ["<>", "!="], ["<", "<"],
                        ["<=", "<="], [">", ">"], [">=", ">="]
                    ]), "OP");
                this.appendValueInput("B")
                    .setCheck("Number");
                this.setOutput(true, "Boolean");
                this.setColour('#D1C4E9');
                this.setInputsInline(true);
                this.setTooltip("Compare two values and return true or false.");
            }
        };

        Blockly.JavaScript.forBlock['logic_compare'] = function (block) {
            const a = Blockly.JavaScript.valueToCode(block, 'A', Blockly.JavaScript.ORDER_ATOMIC) || '0';
            const b = Blockly.JavaScript.valueToCode(block, 'B', Blockly.JavaScript.ORDER_ATOMIC) || '0';
            const op = block.getFieldValue("OP");
            return [`${a} ${op} ${b}`, Blockly.JavaScript.ORDER_RELATIONAL];
        };

        Blockly.Blocks['logic_operation'] = {
            init: function () {
                this.appendValueInput("A").setCheck("Boolean");
                this.appendDummyInput()
                    .appendField(new Blockly.FieldDropdown([
                        ["and", "&"], ["or", "|"]
                    ]), "OP");
                this.appendValueInput("B").setCheck("Boolean");
                this.setOutput(true, "Boolean");
                this.setColour('#D1C4E9');
                this.setInputsInline(true);
                this.setTooltip("Perform logical AND or OR on two values.");
            }
        };

        Blockly.JavaScript.forBlock['logic_operation'] = function (block) {
            const a = Blockly.JavaScript.valueToCode(block, 'A', Blockly.JavaScript.ORDER_ATOMIC) || 'false';
            const b = Blockly.JavaScript.valueToCode(block, 'B', Blockly.JavaScript.ORDER_ATOMIC) || 'false';
            const op = block.getFieldValue("OP");
            return [`${a} ${op} ${b}`, Blockly.JavaScript.ORDER_LOGICAL_AND];
        };


        Blockly.Blocks['logic_negate'] = {
            init: function () {
                this.appendValueInput("INPUT").setCheck("Boolean");
                this.appendDummyInput().appendField("not");
                this.setOutput(true, "Boolean");
                this.setColour('#D1C4E9');
                this.setInputsInline(true);
                this.setTooltip("Negates the input value (true becomes false, false becomes true).");
            }
        };

        Blockly.JavaScript.forBlock['logic_negate'] = function (block) {
            console.log("Entering logic_negate generator");
            const input = Blockly.JavaScript.valueToCode(block, 'INPUT', Blockly.JavaScript.ORDER_LOGICAL_NOT || Blockly.JavaScript.ORDER_HIGH || 1) || 'false';
            console.log(`Input value: ${input}`);
            const code = `not ${input}`;
            return [code, Blockly.JavaScript.ORDER_LOGICAL_NOT || Blockly.JavaScript.ORDER_HIGH || 1];
        };


        Blockly.Blocks['logic_boolean'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldDropdown([["true", "true"], ["false", "false"]]), "BOOL");
                this.setOutput(true, "Boolean");
                this.setColour('#D1C4E9');
                this.setTooltip("Returns a true or false value.");
            }
        };

        Blockly.JavaScript.forBlock['logic_boolean'] = function (block) {
            const value = block.getFieldValue("BOOL");
            return [value, Blockly.JavaScript.ORDER_ATOMIC];
        };

        // Blockly.Blocks Definitions
        Blockly.Blocks['condition_wait_fixed'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("&& Wait")
                    .appendField(new Blockly.FieldNumber(1, 1), "VALUE") // Default value set to 1
                    .appendField(new Blockly.FieldDropdown([
                        ["us", "us"],
                        ["10us", "10us"],
                        ["ms", "ms"],
                        ["10ms", "10ms"],
                        ["s", "s"],  // Default unit set to 's'
                        ["m", "m"],
                        ["h", "h"]
                    ]), "UNIT")
                    .setValue("s"); // Ensuring default selection is 's'

                this.appendValueInput("CONDITION")
                    .setCheck("Boolean")
                    .setAlign(Blockly.ALIGN_RIGHT);
                this.appendValueInput("DELAY_VALUE")
                    .setCheck("Number")
                    .setAlign(Blockly.ALIGN_RIGHT);

                this.setColour(200);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setTooltip("Delays program for a fixed time if a condition is true. Default: 1 second (s). Ranges: us (1-65535), 10us (10-2550), ms (1-65535), 10ms (10-2550), s (1-255), m (1-255), h (1-255).");
            }
        };

        Blockly.Blocks['constant_block_group'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("Group: ")
                    .appendField(new Blockly.FieldTextInput(""), "NAME")
                    .appendField("constants");
                this.appendStatementInput("INNER_BLOCKS")
                    .setCheck(['define_constant']);
                this.setColour(160);
                this.setTooltip("Group Constants blocks inside.");
                this.setInputsInline(true);
            }
        };


        Blockly.Blocks['define_constant'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("Configuration Constant")
                    .appendField(new Blockly.FieldTextInput(""), "NAME")
                    .appendField(" ")
                    .appendField(new Blockly.FieldTextInput(""), "VALUE");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour(160);
                this.setTooltip("Enter a unique constant name and its value");
                this.setOnChange(this.updateFieldState);
            },

            updateFieldState: function (changeEvent) {
                const blockId = this.id;
                const nameField = this.getField("NAME");
                const valueField = this.getField("VALUE");

                if (!nameField || !valueField) return; // Safety check
                let newName = nameField.getValue() || ""; // Get current name value
                newName = newName.toUpperCase(); // Ensure uppercase
                const oldName = nameField.getValue(); // Store the original name before change

                const block = Blockly.getMainWorkspace().getBlockById(changeEvent.blockId);

                // Handle manual changes or duplication
                if (block && (changeEvent.type === Blockly.Events.CHANGE || changeEvent.type === Blockly.Events.CREATE) && !!block.getField("NAME")) {
                    const blocks = Blockly.getMainWorkspace().getAllBlocks();
                    let isDuplicate = blocks.some(b => b !== this && b.type === 'define_constant' && b.getFieldValue("NAME").toUpperCase() === newName);

                    if (isDuplicate) {

                        if (!nameField || typeof nameField !== "string" || nameField.trim() === "") {
                            console.log(`new constant ${blockId} ${block.getField("NAME")}`);
                            return;
                        }


                        // Issue message to ErrorLogConsole for existing name
                        logToWebPageErrors(`Warning: The name "${newName}" already exists for another constant. Please choose a unique name for block ID: ${blockId}\n`, "ERROR");
                        this.setFieldValue(oldName || "", "NAME"); // Revert to old name
                        nameField.setEnabled(true); // Ensure field is editable
                        this.styleEnabledField(nameField); // Apply enabled styling
                        return; // Exit to prevent further processing
                    }


                    // Handle duplication if name was changed to avoid conflict
                    isDuplicate = blocks.some(b => b !== this && b.type === 'define_constant' && b.getFieldValue("NAME").toUpperCase() === newName);
                    if (isDuplicate) {
                        let attempt = 0;
                        let uniqueName = newName;
                        nameField.setEnabled(true); // Enable for duplication attempt
                        this.styleEnabledField(nameField); // Apply enabled styling
                        console.log(`Enabled name field for duplication attempt on block ID: ${blockId}`);

                        while (attempt < 5 && blocks.some(b => b !== this && b.type === 'define_constant' && b.getFieldValue("NAME").toUpperCase() === uniqueName)) {
                            attempt++;
                            uniqueName = "_" + newName + (attempt > 1 ? "_".repeat(attempt - 1) : "");
                        }
                        if (attempt >= 5) {
                            logToWebPageErrors(`Error: Failed to create unique name for constant after 5 attempts. Duplication cancelled for block ID: ${blockId}\n`, "ERROR");
                            this.dispose(); // Cancel duplication by removing the block
                            return;
                        }
                        newName = uniqueName;
                        this.setFieldValue(newName, "NAME");
                    }

                    // Apply uppercase and set state for valid name
                    this.setFieldValue(newName, "NAME"); // Ensure uppercase is applied
                    if (!isDuplicate && newName.trim()) {
                        nameField.setEnabled(false); // Disable for valid unique name
                        this.styleDisabledField(nameField); // Apply disabled styling
                    }
                }
            },

            styleDisabledField: function (field) {
                const textElement = field.getTextElement();
                if (textElement) {
                    const blockColor = this.getColour(); // Use block color for disabled state
                    textElement.style.fill = blockColor; // Match block color
                    textElement.style.opacity = "1"; // Dim to indicate disabled
                    textElement.style.color = 'black';
                }
            },

            styleEnabledField: function (field) {
                const textElement = field.getTextElement();
                if (textElement) {
                    textElement.style.fill = ""; // Reset to default color (usually black)
                    textElement.style.opacity = "1"; // Restore full visibility
                }
            }
        };

        //Blockly.Blocks['define_constant'] = {
        //    init: function () {
        //        this.appendDummyInput()
        //            .appendField("Define Constant")
        //            .appendField(new Blockly.FieldTextInput(""), "NAME")
        //            .appendField(" ")
        //            .appendField(new Blockly.FieldTextInput(""), "VALUE");
        //        this.setPreviousStatement(true, null);
        //        this.setNextStatement(true, null);
        //        this.setColour(160);
        //        this.setTooltip("Enter a unique constant name and its value");
        //        this.setOnChange(function (changeEvent) {
        //            if (changeEvent.type === Blockly.Events.CHANGE && changeEvent.element === "field" && changeEvent.name === "NAME") {
        //                const blockId = this.id;
        //                const newValue = this.getFieldValue("NAME").toUpperCase();
        //                const oldValue = previousName[blockId] || "";
        //                const blocks = Blockly.getMainWorkspace().getAllBlocks();
        //                for (let block of blocks) {
        //                    if (block !== this && block.getFieldValue("NAME") === newValue) {
        //                        logToWebPageErrors(`Error: The name "${newValue}" is already in use. Reverting name.\n`, "ERROR");
        //                        this.setFieldValue(oldValue, "NAME");
        //                        return;
        //                    }
        //                }
        //                previousName[blockId] = newValue;
        //                this.setFieldValue(newValue, "NAME");
        //            }
        //        });
        //    }
        //};

        // Blockly.Blocks['do_loop'] = {
        //     init: function () {
        //         this.appendDummyInput("DO_HEADER")
        //             .appendField("Do")
        //             .appendField(new Blockly.FieldDropdown([
        //                 ["None", "NONE"], ["While", "WHILE"], ["Until", "UNTIL"], ["Forever", "FOREVER"]
        //             ]), "DO_TYPE")
        //             .appendField(new Blockly.FieldTextInput("true"), "DO_CONDITION");
        //         this.appendStatementInput("DO_CODE")
        //             .setCheck(null);
        //         this.appendDummyInput()
        //             .appendField("Exit Do if")
        //             .appendField(new Blockly.FieldTextInput("false"), "EXIT_CONDITION");
        //         this.appendStatementInput("AFTER_EXIT_CODE")
        //             .setCheck(null);
        //         this.appendDummyInput("LOOP_FOOTER")
        //             .appendField("Loop")
        //             .appendField(new Blockly.FieldDropdown([
        //                 ["None", "NONE"], ["While", "WHILE"], ["Until", "UNTIL"]
        //             ]), "LOOP_TYPE")
        //             .appendField(new Blockly.FieldTextInput("true"), "LOOP_CONDITION");
        //         this.setColour('#A5D6A7');
        //         this.setTooltip("1. Generates code for a loop based on a condition.");
        //         this.setPreviousStatement(true, null);
        //         this.setNextStatement(true, null);
        //         this.setOnChange(function (changeEvent) {
        //             var doType = this.getFieldValue("DO_TYPE");
        //             var loopType = this.getFieldValue("LOOP_TYPE");
        //             var doConditionField = this.getField("DO_CONDITION");
        //             var loopConditionField = this.getField("LOOP_CONDITION");
        //             var fieldName;
        //             if (changeEvent.element === "field") {
        //                 fieldName = changeEvent.name;
        //             }
        //             if (doType === "FOREVER") {
        //                 doConditionField.setEnabled(false);
        //                 loopConditionField.setEnabled(false);
        //                 if (loopType !== "NONE") {
        //                     this.setFieldValue("NONE", "LOOP_TYPE");
        //                 }
        //             } else {
        //                 doConditionField.setEnabled(true);
        //                 loopConditionField.setEnabled(true);
        //             }
        //             if (doType !== "NONE" && doType !== "FOREVER" && loopType !== "NONE") {
        //                 if (fieldName === "DO_TYPE") {
        //                     logToWebPageErrors("Cannot set Do criteria when Loop criteria is specified. Change Loop criteria to `None` to enable Do criteria\n", "WARNING");
        //                     this.setFieldValue("NONE", "LOOP_TYPE");
        //                 }
        //                 if (fieldName === "LOOP_TYPE") {
        //                     logToWebPageErrors("Cannot set Loop criteria when Do criteria is specified. Change Do criteria to `None` to enable Loop criteria\n", "WARNING");
        //                     this.setFieldValue("NONE", "DO_TYPE");
        //                 }
        //             }
        //         });
        //     }
        // };

        // Blockly.Blocks['do_loop_simple'] = {
        //     init: function () {
        //         this.appendDummyInput("DO_HEADER")
        //             .appendField("Do")
        //             .appendField(new Blockly.FieldDropdown([
        //                 ["None", "NONE"], ["While", "WHILE"], ["Until", "UNTIL"], ["Forever", "FOREVER"]
        //             ]), "DO_TYPE")
        //             .appendField(new Blockly.FieldTextInput("true"), "DO_CONDITION");
        //         this.appendStatementInput("DO_CODE")
        //             .setCheck(null);
        //         this.appendDummyInput("LOOP_FOOTER")
        //             .appendField("Loop")
        //             .appendField(new Blockly.FieldDropdown([
        //                 ["None", "NONE"], ["While", "WHILE"], ["Until", "UNTIL"]
        //             ]), "LOOP_TYPE")
        //             .appendField(new Blockly.FieldTextInput("true"), "LOOP_CONDITION");
        //         this.setColour('#A5D6A7');
        //         this.setTooltip("2. Generates a simple loop without an exit condition.");
        //         this.setPreviousStatement(true, null);
        //         this.setNextStatement(true, null);
        //         this.setOnChange(function (changeEvent) {
        //             var doType = this.getFieldValue("DO_TYPE");
        //             var loopType = this.getFieldValue("LOOP_TYPE");
        //             var doConditionField = this.getField("DO_CONDITION");
        //             var loopConditionField = this.getField("LOOP_CONDITION");
        //             var fieldName;
        //             if (changeEvent.element === "field") {
        //                 fieldName = changeEvent.name;
        //             }
        //             if (doType === "FOREVER") {
        //                 doConditionField.setEnabled(false);
        //                 loopConditionField.setEnabled(false);
        //                 if (loopType !== "NONE") {
        //                     this.setFieldValue("NONE", "LOOP_TYPE");
        //                 }
        //             } else {
        //                 doConditionField.setEnabled(true);
        //                 loopConditionField.setEnabled(true);
        //             }
        //             if (doType !== "NONE" && doType !== "FOREVER" && loopType !== "NONE") {
        //                 if (fieldName === "DO_TYPE") {
        //                     logToWebPageErrors("Cannot set Do criteria when Loop criteria is specified. Change Loop criteria to `None` to enable Do criteria\n", "WARNING");
        //                     this.setFieldValue("NONE", "LOOP_TYPE");
        //                 }
        //                 if (fieldName === "LOOP_TYPE") {
        //                     logToWebPageErrors("Cannot set Loop criteria when Do criteria is specified. Change Do criteria to `None` to enable Loop criteria\n", "WARNING");
        //                     this.setFieldValue("NONE", "DO_TYPE");
        //                 }
        //             }
        //         });
        //     }
        // };

// Revised do_loop block with logic statement inputs
    Blockly.Blocks['do_loop'] = {
        init: function () {
            this.appendDummyInput("DO_HEADER")
                .appendField("Do")
                .appendField(new Blockly.FieldDropdown([
                    ["None", "NONE"], ["While", "WHILE"], ["Until", "UNTIL"], ["Forever", "FOREVER"]
                ]), "DO_TYPE");
            this.appendValueInput("DO_CONDITION")
                .setCheck("Boolean")
                .setAlign(Blockly.ALIGN_RIGHT);
            this.appendStatementInput("DO_CODE")
                .setCheck(null);
            this.appendDummyInput("EXIT_HEADER")
                .appendField("Exit Do if");
            this.appendValueInput("EXIT_CONDITION")
                .setCheck("Boolean")
                .setAlign(Blockly.ALIGN_RIGHT);
            this.appendStatementInput("AFTER_EXIT_CODE")
                .setCheck(null);
            this.appendDummyInput("LOOP_FOOTER")
                .appendField("Loop")
                .appendField(new Blockly.FieldDropdown([
                    ["None", "NONE"], ["While", "WHILE"], ["Until", "UNTIL"]
                ]), "LOOP_TYPE");
            this.appendValueInput("LOOP_CONDITION")
                .setCheck("Boolean")
                .setAlign(Blockly.ALIGN_RIGHT);
            this.setInputsInline(true); // Added to make inputs inline
            this.setColour('#A5D6A7');
            this.setTooltip("Executes a loop with optional Do, Exit, and Loop conditions using logic statements.");
            this.setPreviousStatement(true, null);
            this.setNextStatement(true, null);
            this.setOnChange(function (changeEvent) {
                var doType = this.getFieldValue("DO_TYPE");
                var loopType = this.getFieldValue("LOOP_TYPE");
                var doConditionInput = this.getInput("DO_CONDITION");
                var loopConditionInput = this.getInput("LOOP_CONDITION");
                var fieldName;
                if (changeEvent.element === "field") {
                    fieldName = changeEvent.name;
                }
                if (doType === "FOREVER") {
                    doConditionInput.connection.setShadowDom(null);
                    loopConditionInput.connection.setShadowDom(null);
                    if (loopType !== "NONE") {
                        this.setFieldValue("NONE", "LOOP_TYPE");
                    }
                } else {
                    doConditionInput.connection.setShadowDom(null);
                    loopConditionInput.connection.setShadowDom(null);
                }
                if (doType !== "NONE" && doType !== "FOREVER" && loopType !== "NONE") {
                    if (fieldName === "DO_TYPE") {
                        logToWebPageErrors("Cannot set Do criteria when Loop criteria is specified. Change Loop criteria to `None` to enable Do criteria\n", "WARNING");
                        this.setFieldValue("NONE", "LOOP_TYPE");
                    }
                    if (fieldName === "LOOP_TYPE") {
                        logToWebPageErrors("Cannot set Loop criteria when Do criteria is specified. Change Do criteria to `None` to enable Loop criteria\n", "WARNING");
                        this.setFieldValue("NONE", "DO_TYPE");
                    }
                }
            });
        }
    };

    // Revised do_loop_simple block with logic statement inputs
    Blockly.Blocks['do_loop_simple'] = {
        init: function () {
            this.appendDummyInput("DO_HEADER")
                .appendField("Do")
                .appendField(new Blockly.FieldDropdown([
                    ["None", "NONE"], ["While", "WHILE"], ["Until", "UNTIL"], ["Forever", "FOREVER"]
                ]), "DO_TYPE");
            this.appendValueInput("DO_CONDITION")
                .setCheck("Boolean")
                .setAlign(Blockly.ALIGN_RIGHT);
            this.appendStatementInput("DO_CODE")
                .setCheck(null);
            this.appendDummyInput("LOOP_FOOTER")
                .appendField("Loop")
                .appendField(new Blockly.FieldDropdown([
                    ["None", "NONE"], ["While", "WHILE"], ["Until", "UNTIL"]
                ]), "LOOP_TYPE");
            this.appendValueInput("LOOP_CONDITION")
                .setCheck("Boolean")
                .setAlign(Blockly.ALIGN_RIGHT);
            this.setInputsInline(true); // Added to make inputs inline
            this.setColour('#A5D6A7');
            this.setTooltip("Executes a simple loop with optional Do and Loop conditions using logic statements.");
            this.setPreviousStatement(true, null);
            this.setNextStatement(true, null);
            this.setOnChange(function (changeEvent) {
                var doType = this.getFieldValue("DO_TYPE");
                var loopType = this.getFieldValue("LOOP_TYPE");
                var doConditionInput = this.getInput("DO_CONDITION");
                var loopConditionInput = this.getInput("LOOP_CONDITION");
                var fieldName;
                if (changeEvent.element === "field") {
                    fieldName = changeEvent.name;
                }
                if (doType === "FOREVER") {
                    doConditionInput.connection.setShadowDom(null);
                    loopConditionInput.connection.setShadowDom(null);
                    if (loopType !== "NONE") {
                        this.setFieldValue("NONE", "LOOP_TYPE");
                    }
                } else {
                    doConditionInput.connection.setShadowDom(null);
                    loopConditionInput.connection.setShadowDom(null);
                }
                if (doType !== "NONE" && doType !== "FOREVER" && loopType !== "NONE") {
                    if (fieldName === "DO_TYPE") {
                        logToWebPageErrors("Cannot set Do criteria when Loop criteria is specified. Change Loop criteria to `None` to enable Do criteria\n", "WARNING");
                        this.setFieldValue("NONE", "LOOP_TYPE");
                    }
                    if (fieldName === "LOOP_TYPE") {
                        logToWebPageErrors("Cannot set Loop criteria when Do criteria is specified. Change Do criteria to `None` to enable Loop criteria\n", "WARNING");
                        this.setFieldValue("NONE", "DO_TYPE");
                    }
                }
            });
        }
    };

    // JavaScript generator for do_loop
    Blockly.JavaScript.forBlock['do_loop'] = function (block) {
        var currentIndent = indentationStack[indentationStack.length - 1] || 1;
        indentationStack[indentationStack.length - 1] = currentIndent;
        var doType = block.getFieldValue('DO_TYPE');
        var doCondition = Blockly.JavaScript.valueToCode(block, 'DO_CONDITION', Blockly.JavaScript.ORDER_ATOMIC) || 'true';
        var loopType = block.getFieldValue('LOOP_TYPE');
        var loopCondition = Blockly.JavaScript.valueToCode(block, 'LOOP_CONDITION', Blockly.JavaScript.ORDER_ATOMIC) || 'true';
        var exitCondition = Blockly.JavaScript.valueToCode(block, 'EXIT_CONDITION', Blockly.JavaScript.ORDER_ATOMIC) || '';
        var doCode = Blockly.JavaScript.statementToCode(block, 'DO_CODE') || '';
        var afterExitCode = Blockly.JavaScript.statementToCode(block, 'AFTER_EXIT_CODE') || '';
        var code = [];

        // Generate Do header
        if (doType === "WHILE") {
            code.push(tab() + `Do While ${doCondition}`);
        } else if (doType === "UNTIL") {
            code.push(tab() + `Do Until ${doCondition}`);
        } else if (doType === "FOREVER") {
            code.push(tab() + 'Do');
        } else {
            code.push(tab() + 'Do');
        }

        // Indent body
        indentationStack[indentationStack.length - 1]++;
        if (doCode.trim()) {
            code.push(reformatCode(doCode, indentationStack[indentationStack.length - 1]));
        } else {
            code.push(tab() + '\' No DO_CODE provided');
        }

        // Generate Exit Do if no logic statement is provided
        if (!exitCondition) {
            code.push(tab() + 'Exit Do');
        } else if (exitCondition && exitCondition !== 'true' && exitCondition !== 'false') {
            code.push(tab() + `If ${exitCondition} Then Exit Do`);
        }

        // Generate after exit code
        if (afterExitCode.trim()) {
            code.push(reformatCode(afterExitCode, indentationStack[indentationStack.length - 1]));
        }

        // Restore indent
        indentationStack[indentationStack.length - 1] = currentIndent;

        // Generate Loop footer
        if (doType === "NONE" && loopType === "WHILE") {
            code.push(tab() + `Loop While ${loopCondition}`);
        } else if (doType === "NONE" && loopType === "UNTIL") {
            code.push(tab() + `Loop Until ${loopCondition}`);
        } else {
            code.push(tab() + 'Loop');
        }

        code = code.join('\n') + '\n';
        return formatComment(block, code, indentationStack);
    };

    // JavaScript generator for do_loop_simple
    Blockly.JavaScript.forBlock['do_loop_simple'] = function (block) {
        var currentIndent = indentationStack[indentationStack.length - 1] || 1;
        indentationStack[indentationStack.length - 1] = currentIndent;
        var doType = block.getFieldValue('DO_TYPE');
        var doCondition = Blockly.JavaScript.valueToCode(block, 'DO_CONDITION', Blockly.JavaScript.ORDER_ATOMIC) || 'true';
        var loopType = block.getFieldValue('LOOP_TYPE');
        var loopCondition = Blockly.JavaScript.valueToCode(block, 'LOOP_CONDITION', Blockly.JavaScript.ORDER_ATOMIC) || 'true';
        var doCode = Blockly.JavaScript.statementToCode(block, 'DO_CODE') || '';
        var code = [];

        // Generate Do header
        if (doType === "WHILE") {
            code.push(tab() + `Do While ${doCondition}`);
        } else if (doType === "UNTIL") {
            code.push(tab() + `Do Until ${doCondition}`);
        } else if (doType === "FOREVER") {
            code.push(tab() + 'Do');
        } else {
            code.push(tab() + 'Do');
        }

        // Indent body
        indentationStack[indentationStack.length - 1]++;
        if (doCode.trim()) {
            code.push(reformatCode(doCode, indentationStack[indentationStack.length - 1]));
        } else {
            code.push(tab() + '\' No DO_CODE provided');
        }

        // Restore indent
        indentationStack[indentationStack.length - 1] = currentIndent;

        // Generate Loop footer
        if (doType === "NONE" && loopType === "WHILE") {
            code.push(tab() + `Loop While ${loopCondition}`);
        } else if (doType === "NONE" && loopType === "UNTIL") {
            code.push(tab() + `Loop Until ${loopCondition}`);
        } else {
            code.push(tab() + 'Loop');
        }

        code = code.join('\n') + '\n';
        return formatComment(block, code, indentationStack);
    };

        Blockly.Blocks['do_loop_simplest'] = {
            init: function () {
                this.appendDummyInput("DO_HEADER")
                    .appendField("Do");
                this.appendStatementInput("DO_CODE")
                    .setCheck(null);
                this.appendDummyInput("LOOP_FOOTER")
                    .appendField("Loop");
                this.setColour('#A5D6A7');
                this.setTooltip("2. Generates a simple loop without an exit condition.");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
            }
        };

        Blockly.Blocks['export_code'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("Export Code");
                this.setColour(180);
                this.setTooltip("Converts Blockly blocks to GCBASIC.");
            }
        };

        Blockly.Blocks['get_variable'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldVariable("myVar"), "VAR_NAME");
                this.setColour('#EF9A9A');
                this.setOutput(true, null);
                this.setTooltip("Gets a variable.");
            },
            onchange: function (event) {
                if (event.type === Blockly.Events.VAR_RENAME) {
                    var workspace = this.workspace;
                    var oldName = event.oldName;
                    var newName = event.newName;
                    var numBlock = workspace.getAllBlocks().find(block =>
                        block.type === 'numeric_variable' && block.getFieldValue("VAR_NAME") === oldName
                    );
                    if (numBlock) {
                        numBlock.setFieldValue(newName, "VAR_NAME");
                    }
                }
            }
        };

        Blockly.Blocks['import_blocks'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("Import Blocks");
                this.setColour(180);
                this.setTooltip("Loads blocks from an XML file without clearing existing ones.");
            }
        };

        Blockly.Blocks['lcd_cls'] = {
            init: function () {
                this.appendDummyInput().appendField("CLS");
                this.setColour(200);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
            }
        };

        Blockly.Blocks['math_modulo'] = {
            init: function () {
                this.appendValueInput("A")
                    .setCheck(null)
                    .appendField("Modulo");
                this.appendValueInput("B")
                    .setCheck(null)
                    .appendField("mod");
                this.setInputsInline(true); // Makes the value inputs inline with each other
                this.setColour('#2196F3');
                this.setOutput(true, null);
                this.setTooltip("Returns the remainder of dividing the first number by the second.");
            }
        };

        Blockly.Blocks['math_number'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldNumber(0), "NUMBER");
                this.setColour('#2196F3');
                this.setOutput(true, null);
                this.setTooltip("A number value.");
            }
        };

        Blockly.Blocks['math_odd_even'] = {
            init: function () {
                this.appendValueInput("NUMBER")
                    .setCheck(null)
                    .appendField("Is number");
                this.appendDummyInput()
                    .appendField(new Blockly.FieldDropdown([
                        ["odd", "ODD"],
                        ["even", "EVEN"]
                    ]), "CHECK");
                this.setColour('#2196F3');
                this.setOutput(true, null);
                this.setTooltip("Checks if a number is odd or even.");
            }
        };

        Blockly.Blocks['math_operation'] = {
            init: function () {
                this.appendValueInput("A")
                    .setCheck(null)
                    .appendField("Calculate");
                this.appendValueInput("B")
                    .setCheck(null)
                    .appendField(new Blockly.FieldDropdown([
                        ["+", "+"],
                        ["-", "-"],
                        ["*", "*"],
                        ["/", "/"]
                    ]), "OPERATOR")
                    .setAlign(Blockly.ALIGN_RIGHT);
                this.setInputsInline(true);
                this.setColour('#2196F3');
                this.setOutput(true, null);
                this.setTooltip("Performs addition, subtraction, multiplication, or division on two numbers.");
            }
        };

        Blockly.Blocks['math_operations'] = {
            init: function () {
                this.appendValueInput("A")
                    .setCheck("Number")
                    .appendField("Calculate");
                this.appendDummyInput()
                    .appendField(new Blockly.FieldDropdown([
                        ["+", "ADD"],
                        ["-", "SUBTRACT"],
                        ["*", "MULTIPLY"],
                        ["/", "DIVIDE"]
                    ]), "OPERATOR");
                this.appendValueInput("B")
                    .setCheck("Number");
                this.setOutput(true, "Number");
                this.setColour('#2196F3');
                this.setTooltip("Perform a basic math operation.");
            }
        };

        Blockly.Blocks['numeric_variable'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("Dim")
                    .appendField(new Blockly.FieldTextInput(""), "VAR_NAME")
                    .appendField("As")
                    .appendField(new Blockly.FieldDropdown([
                        ["Byte", "Byte"],
                        ["Word", "Word"],
                        ["Integer", "Integer"],
                        ["Long", "Long"]
                    ]), "VAR_TYPE")
                    .appendField("=")
                    .appendField(new Blockly.FieldNumber(0), "INITIAL_VALUE");
                this.setColour('#EF9A9A');
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setTooltip("Declares a numeric variable.");
            }
        };

        Blockly.Blocks['open_project'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("Open Project");
                this.setColour(180);
                this.setTooltip("Loads a saved Blockly project.");
            }
        };

        Blockly.Blocks['print_text'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("Print")
                    .appendField(new Blockly.FieldTextInput('"Hello World!"', this.validateField), "TEXT");
                this.setColour('#FFCA28');
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
            },
            validateField: function (newValue) {
                if (newValue.startsWith('"') && !newValue.endsWith('"')) {
                    logToWebPageErrors(`Error: Unterminated string "${newValue}" in Text field`, "ERROR");
                    return newValue;
                }
                return newValue;
            }
        };

        Blockly.Blocks['repeat_loop'] = {
            init: function () {
                this.appendDummyInput("REPEAT_HEADER")
                    .appendField("Repeat")
                    .appendField(new Blockly.FieldDropdown([
                        ["Forever", "FOREVER"],
                        ["Times", "TIMES"]
                    ]), "REPEAT_TYPE")
                    .appendField(new Blockly.FieldTextInput("1"), "REPEAT_COUNT");
                this.appendStatementInput("REPEAT_CODE")
                    .setCheck(null);
                this.appendDummyInput()
                    .appendField("Exit Repeat if")
                    .appendField(new Blockly.FieldTextInput("false"), "EXIT_CONDITION");
                this.appendStatementInput("AFTER_EXIT_CODE")
                    .setCheck(null);
                this.appendDummyInput()
                    .appendField("End Repeat");
                this.setColour('#A5D6A7');
                this.setTooltip("Repeats code forever or a specified number of times with optional early exit.");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setOnChange(function (changeEvent) {
                    var repeatType = this.getFieldValue("REPEAT_TYPE");
                    var repeatCountField = this.getField("REPEAT_COUNT");
                    if (repeatType === "FOREVER") {
                        repeatCountField.setEnabled(false);
                        repeatCountField.setValue("");
                    } else {
                        repeatCountField.setEnabled(true);
                        if (!repeatCountField.getValue()) {
                            repeatCountField.setValue("1");
                        }
                    }
                });
            }
        };

        Blockly.Blocks['repeat_loop_simple'] = {
            init: function () {
                this.appendDummyInput("REPEAT_HEADER")
                    .appendField("Repeat")
                    .appendField(new Blockly.FieldDropdown([
                        ["Times", "TIMES"]
                    ]), "REPEAT_TYPE")
                    .appendField(new Blockly.FieldTextInput("1"), "REPEAT_COUNT");
                this.appendStatementInput("REPEAT_CODE")
                    .setCheck(null);
                this.appendDummyInput()
                    .appendField("End Repeat");
                this.setColour('#A5D6A7');
                this.setTooltip("Repeats code forever or a specified number of times without early exit.");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setOnChange(function (changeEvent) {
                    var repeatType = this.getFieldValue("REPEAT_TYPE");
                    var repeatCountField = this.getField("REPEAT_COUNT");
                    if (repeatType === "FOREVER") {
                        repeatCountField.setEnabled(false);
                        repeatCountField.setValue("");
                    } else {
                        repeatCountField.setEnabled(true);
                        if (!repeatCountField.getValue()) {
                            repeatCountField.setValue("1");
                        }
                    }
                });
            }
        };

        Blockly.Blocks['reset_workspace'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("Reset Workspace");
                this.setColour(180);
                this.setTooltip("Clears all blocks with confirmation.");
            }
        };

        Blockly.Blocks['save_project'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("Save Project");
                this.setColour(180);
                this.setTooltip("Saves the current workspace as an XML file.");
            }
        };

        Blockly.Blocks['select_chip'] = {
            init: function() {
                this.chipOptions = this.getChipOptions('');
                this.selectedChip = this.chipOptions.length > 0 ? this.chipOptions[0][1] : '';
                this.currentFilter = '';
                
                this.appendDummyInput()
                    .appendField("Select Chip")
                    .appendField(" ")
                    
                    .appendField(new Blockly.FieldTextInput('', this.onFilterInput.bind(this)), "FILTER")
                    .appendField(new Blockly.FieldDropdown(
                        this.chipOptions,
                        this.onDropdownChange.bind(this)
                    ), "CHIP");
                
                this.setColour(230);
                this.setTooltip("Type in the text field to filter chips, then select from dropdown");
                this.setHelpUrl("");
                
                // Set initial dropdown value
                if (this.chipOptions.length > 0) {
                    this.setFieldValue(this.chipOptions[0][1], 'CHIP');
                }
            },
            
            getChipOptions: function(filter) {
                filter = filter || '';
                // console.log("Getting chip options with filter:", filter);
                
                // Ensure chipData exists and is an array
                if (!Array.isArray(window.chipData) && !Array.isArray(chipData)) {
                    // console.warn('chipData not found or not an array');
                    return [['No chips available', '']];
                }
                
                var data = window.chipData || chipData;
                var names = data
                    .map(function(chip) { return chip.name; })
                    .filter(function(name) { return typeof name === 'string' && name.trim() !== ''; });
                
                // Remove duplicates and sort
                var uniqueNames = [];
                var seen = {};
                for (var i = 0; i < names.length; i++) {
                    if (!seen[names[i]]) {
                        seen[names[i]] = true;
                        uniqueNames.push(names[i]);
                    }
                }
                
                var sortedNames = uniqueNames.sort(function(a, b) { return a.localeCompare(b); });
                
                // Apply filter if provided
                if (filter && filter.trim() !== '') {
                    var lowerFilter = filter.toLowerCase().trim();
                    // Prioritize starts-with matches, then includes matches
                    var startsWithMatches = sortedNames.filter(function(name) {
                        return name.toLowerCase().indexOf(lowerFilter) === 0;
                    });
                    var includesMatches = sortedNames.filter(function(name) {
                        return name.toLowerCase().indexOf(lowerFilter) > -1 && 
                            name.toLowerCase().indexOf(lowerFilter) !== 0;
                    });
                    sortedNames = startsWithMatches.concat(includesMatches);
                }
                
                // console.log("Filtered chip options:", sortedNames.length, "items");
                return sortedNames.length > 0 
                    ? sortedNames.map(function(name) { return [name, name]; })
                    : [['No matches found', '']];
            },
            
            onFilterInput: function(newValue) {
                // Prevent recursion when clearing filter from dropdown selection
                if (this.clearingFilter) {
                    return newValue;
                }
                
                // console.log("Filter input changed to:", newValue);
                this.currentFilter = newValue || '';
                
                // Get filtered options
                var filteredOptions = this.getChipOptions(this.currentFilter);
                this.chipOptions = filteredOptions;
                
                // Update the dropdown field's menu
                var dropdownField = this.getField('CHIP');
                if (dropdownField) {
                    // Update the menu generator
                    dropdownField.menuGenerator_ = filteredOptions;
                    
                    // If we have matches, auto-select the first one
                    if (filteredOptions.length > 0 && filteredOptions[0][1] !== 'No matches found') {
                        var firstMatch = filteredOptions[0][1];
                        this.selectedChip = firstMatch;
                        dropdownField.setValue(firstMatch);
                        // console.log("Auto-selected first match:", firstMatch);
                    } else if (filteredOptions.length === 0 || filteredOptions[0][1] === 'No matches found') {
                        // Clear selection if no matches
                        this.selectedChip = '';
                        dropdownField.setValue('');
                    }
                    
                    // Force the dropdown to rebuild its menu if it's currently open
                    if (dropdownField.menu_) {
                        dropdownField.menu_.dispose();
                        dropdownField.menu_ = null;
                    }
                }
                
                return newValue;
            },
            
            onDropdownChange: function(newValue) {
                // console.log("Dropdown selection changed to:", newValue);
                this.selectedChip = newValue;
                
                // Use a flag to prevent recursion when clearing the filter
                this.clearingFilter = true;
                
                // Clear the filter field when a selection is made
                this.setFieldValue('', 'FILTER');
                this.currentFilter = '';
                
                // Reset dropdown to show all options for next time
                this.chipOptions = this.getChipOptions('');
                var dropdownField = this.getField('CHIP');
                if (dropdownField) {
                    dropdownField.menuGenerator_ = this.chipOptions;
                }
                
                // Clear the flag after a brief delay
                var self = this;
                setTimeout(function() {
                    self.clearingFilter = false;
                }, 10);
                
                return newValue;
            },
            
            getSelectedChip: function() {
                return this.selectedChip || this.getFieldValue('CHIP');
            },
            
            getFilterText: function() {
                return this.getFieldValue('FILTER') || '';
            },
            
            setSelectedChip: function(chipName) {
                var dropdownField = this.getField('CHIP');
                if (dropdownField) {
                    // First, clear any filter to show all options
                    this.setFieldValue('', 'FILTER');
                    this.currentFilter = '';
                    
                    // Reset to all options
                    this.chipOptions = this.getChipOptions('');
                    dropdownField.menuGenerator_ = this.chipOptions;
                    
                    // Check if the chip exists
                    var chipExists = false;
                    for (var i = 0; i < this.chipOptions.length; i++) {
                        if (this.chipOptions[i][1] === chipName) {
                            chipExists = true;
                            break;
                        }
                    }
                    
                    if (chipExists) {
                        this.selectedChip = chipName;
                        dropdownField.setValue(chipName);
                        // console.log("Set selected chip to:", chipName);
                    } else {
                        console.warn('Chip not found:', chipName);
                    }
                }
            },
            
            clearFilter: function() {
                this.setFieldValue('', 'FILTER');
                this.onFilterInput('');
            },
            
            // Utility method to get all available chips (unfiltered)
            getAllChips: function() {
                return this.getChipOptions('');
            }
        };
        
        Blockly.Blocks['set_variable'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("Set")
                    .appendField(new Blockly.FieldVariable("myVar"), "VAR_NAME")
                    .appendField("=");
                this.appendValueInput("VALUE")
                    .setCheck(null)
                    .setAlign(Blockly.ALIGN_RIGHT);
                this.setInputsInline(true); // Makes the value input inline with the fields
                this.setColour('#EF9A9A');
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setTooltip("Sets a variable.");
            },
            onchange: function (event) {
                if (event.type === Blockly.Events.VAR_RENAME) {
                    var workspace = this.workspace;
                    var oldName = event.oldName;
                    var newName = event.newName;
                    var numBlock = workspace.getAllBlocks().find(block =>
                        block.type === 'numeric_variable' && block.getFieldValue("VAR_NAME") === oldName
                    );
                    if (numBlock) {
                        numBlock.setFieldValue(newName, "VAR_NAME");
                    }
                }
            }
        };

        //Blockly.Blocks['set_variable'] = {
        //    init: function () {
        //        this.appendDummyInput()
        //            .appendField("Set")
        //            .appendField(new Blockly.FieldVariable("myVar"), "VAR_NAME")
        //            .appendField("=");
        //        this.appendValueInput("VALUE")
        //            .setCheck(null)
        //            .setAlign(Blockly.ALIGN_RIGHT);
        //        this.setColour('#EF9A9A');
        //        this.setPreviousStatement(true, null);
        //        this.setNextStatement(true, null);
        //        this.setTooltip("Sets a variable.");
        //    },
        //    onchange: function (event) {
        //        if (event.type === Blockly.Events.VAR_RENAME) {
        //            var workspace = this.workspace;
        //            var oldName = event.oldName;
        //            var newName = event.newName;
        //            var numBlock = workspace.getAllBlocks().find(block =>
        //                block.type === 'numeric_variable' && block.getFieldValue("VAR_NAME") === oldName
        //            );
        //            if (numBlock) {
        //                numBlock.setFieldValue(newName, "VAR_NAME");
        //            }
        //        }
        //    }
        //};

        Blockly.Blocks['string_variable'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("Dim")
                    .appendField(new Blockly.FieldTextInput("mystring"), "VAR_NAME")
                    .appendField("As String *")
                    .appendField(new Blockly.FieldNumber(10, 1, 255), "LENGTH")
                    .appendField("=")
                    .appendField(new Blockly.FieldTextInput("\"\""), "INITIAL_VALUE");
                this.setColour('#EF9A9A');
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setTooltip("Declares a string variable with a specified name, length (1-255), and initial value.");
            }
        };

        Blockly.Blocks['variable_block_group'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("Group: ")
                    .appendField(new Blockly.FieldTextInput(""), "NAME")
                    .appendField("variables");
                this.appendStatementInput("INNER_BLOCKS")
                    .setCheck(['numeric_variable']);
                this.setColour('#EF9A9A');
                this.setTooltip("Group Variable Defintions blocks inside.");
                this.setInputsInline(true);
            }
        };

        Blockly.Blocks['wait_100ms'] = {
            init: function () {
                this.appendDummyInput().appendField("Wait 100ms");
                this.setColour(200);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
            }
        };

        Blockly.Blocks['wait_conditional'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("Wait")
                    .appendField(new Blockly.FieldDropdown([
                        ["While", "WHILE"],
                        ["Until", "UNTIL"]
                    ]), "MODE")
                    .appendField("&&");
                this.appendValueInput("CONDITION")
                    .setCheck("Boolean")
                    .setAlign(Blockly.ALIGN_RIGHT);
                this.setColour(200);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setTooltip("Delays program while or until a condition is true.");
            }
        };


        Blockly.Blocks['wait_fixed'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("Wait")
                    .appendField(new Blockly.FieldLabel("[", "OPEN_BRACKET"))
                    .appendField(new Blockly.FieldNumber(1, 1), "VALUE")
                    .appendField("or");
                this.appendValueInput("DELAY_VALUE")
                    .setCheck("Number")
                    .setAlign(Blockly.ALIGN_RIGHT);
                this.appendDummyInput()
                    .appendField(new Blockly.FieldLabel("]", "CLOSE_BRACKET"))
                    .appendField(new Blockly.FieldDropdown([
                        ["s", "s"],
                        ["us", "us"],
                        ["10us", "10us"],
                        ["ms", "ms"],
                        ["10ms", "10ms"],
                        ["m", "m"],
                        ["h", "h"]
                    ]), "UNIT")
                this.setColour(200);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setTooltip("Delays program for a fixed time.");

                this.setOnChange(this.updateFieldState);
            },

            updateFieldState: function () {
                let valueField = this.getField("VALUE");
                let delayInput = this.getInput("DELAY_VALUE");

                if (valueField && delayInput) {
                    let hasConnection = delayInput.connection && delayInput.connection.targetConnection;
                    let targetBlock = delayInput.connection && delayInput.connection.targetBlock();
                    let isTargetEnabled = targetBlock ? targetBlock.isEnabled() : true; // True if no target

                    if (hasConnection && isTargetEnabled) {
                        valueField.setEnabled(false);
                        this.styleDisabledField(valueField);
                    } else {
                        valueField.setEnabled(true);
                        this.styleEnabledField(valueField);
                    }
                }
            },

            styleDisabledField: function (field) {
                let blockColor = this.getColour();  // Get parent block color
                let textElement = field.getTextElement();

                if (textElement) {
                    textElement.style.fill = blockColor;  // Match block color
                    textElement.style.opacity = "0.5";  // Dim for readability
                }
            },

            styleEnabledField: function (field) {
                let textElement = field.getTextElement();

                if (textElement) {
                    textElement.style.fill = "";  // Restore original color
                    textElement.style.opacity = "1";  // Reset visibility
                }
            }
        };

        //Blockly.Blocks['wait_fixed'] = {
        //    init: function () {
        //        this.appendDummyInput()
        //            .appendField("Wait")
        //            .appendField(new Blockly.FieldLabel("[", "OPEN_BRACKET"))
        //            .appendField(new Blockly.FieldNumber(1, 1), "VALUE")
        //            .appendField("or");
        //        this.appendValueInput("DELAY_VALUE")
        //            .setCheck("Number")
        //            .setAlign(Blockly.ALIGN_RIGHT);
        //        this.appendDummyInput()
        //            .appendField(new Blockly.FieldLabel("]", "CLOSE_BRACKET"))
        //            .appendField(new Blockly.FieldDropdown([
        //                ["us", "us"],
        //                ["10us", "10us"],
        //                ["ms", "ms"],
        //                ["10ms", "10ms"],
        //                ["s", "s"],
        //                ["m", "m"],
        //                ["h", "h"]
        //            ]), "UNIT");
        //        this.setColour(200);
        //        this.setPreviousStatement(true, null);
        //        this.setNextStatement(true, null);
        //        this.setTooltip("Delays program for a fixed time.");

        //        this.setOnChange(this.updateFieldState);
        //    },

        //    updateFieldState: function () {
        //        let valueField = this.getField("VALUE");
        //        let delayInput = this.getInput("DELAY_VALUE");

        //        if (valueField && delayInput) {
        //            let hasConnection = delayInput.connection && delayInput.connection.targetConnection;

        //            if (hasConnection) {
        //                valueField.setEnabled(false);
        //                this.styleDisabledField(valueField);
        //            } else {
        //                valueField.setEnabled(true);
        //                this.styleEnabledField(valueField);
        //            }
        //        }
        //    },

        //    styleDisabledField: function (field) {
        //        let blockColor = this.getColour();  // Get parent block color
        //        let textElement = field.getTextElement();

        //        if (textElement) {
        //            textElement.style.fill = blockColor;  // Match block color
        //            textElement.style.opacity = "0.5";  // Dim for readability
        //        }
        //    },

        //    styleEnabledField: function (field) {
        //        let textElement = field.getTextElement();

        //        if (textElement) {
        //            textElement.style.fill = "";  // Restore original color
        //            textElement.style.opacity = "1";  // Reset visibility
        //        }
        //    }
        //};


        // Blockly.JavaScript.forBlock Definitions
        //Blockly.JavaScript.forBlock['condition_wait_fixed'] = function (block) {
        //    var condition = Blockly.JavaScript.valueToCode(block, 'CONDITION', Blockly.JavaScript.ORDER_ATOMIC) || 'true';
        //    var value = Blockly.JavaScript.valueToCode(block, 'DELAY_VALUE', Blockly.JavaScript.ORDER_ATOMIC) || block.getFieldValue('VALUE');
        //    var unit = block.getFieldValue('UNIT');
        //    return tab() + `If ${condition} Then Wait ${value} ${unit}\n`;
        //};

        Blockly.JavaScript.forBlock['constant_block_group'] = function (block) {
            var innerBlocksCode = Blockly.JavaScript.statementToCode(block, 'INNER_BLOCKS');
            return `${innerBlocksCode}`;
        };

        Blockly.JavaScript.forBlock['define_constant'] = function (block) {
            var name = block.getFieldValue('NAME');
            var value = block.getFieldValue('VALUE') || '';
            code = tab() + `#DEFINE ${name} ${value}\n`;
            return formatComment(block, code, indentationStack);
        };

        // Blockly.JavaScript.forBlock['do_loop'] = function (block) {
        //     var currentIndent = indentationStack[indentationStack.length - 1] || 1;
        //     indentationStack[indentationStack.length - 1] = currentIndent;
        //     var doType = block.getFieldValue('DO_TYPE');
        //     var doCondition = sanitizeCondition(block.getFieldValue('DO_CONDITION'));
        //     var loopType = block.getFieldValue('LOOP_TYPE');
        //     var loopCondition = sanitizeCondition(block.getFieldValue('LOOP_CONDITION'));
        //     var exitCondition = sanitizeCondition(block.getFieldValue('EXIT_CONDITION'));
        //     var doCode = Blockly.JavaScript.statementToCode(block, 'DO_CODE') || '';
        //     var afterExitCode = Blockly.JavaScript.statementToCode(block, 'AFTER_EXIT_CODE') || '';
        //     var code = [];
        //     if (doType === "WHILE") {
        //         code.push(tab() + `Do While ${doCondition}`);
        //     } else if (doType === "UNTIL") {
        //         code.push(tab() + `Do Until ${doCondition}`);
        //     } else if (doType === "FOREVER") {
        //         code.push(tab() + 'Do');
        //     } else {
        //         code.push(tab() + 'Do');
        //     }
        //     indentationStack[indentationStack.length - 1]++;
        //     if (doCode.trim()) {
        //         code.push(reformatCode(doCode, indentationStack[indentationStack.length - 1]));
        //     } else {
        //         code.push(tab() + '\' No DO_CODE provided');
        //     }
        //     if (exitCondition && exitCondition !== 'true' && exitCondition !== 'false') {
        //         code.push(tab() + `If ${exitCondition} Then Exit Do`);
        //     } else if (exitCondition === 'true') {
        //         code.push(tab() + 'Exit Do');
        //     }
        //     if (afterExitCode.trim()) {
        //         code.push(reformatCode(afterExitCode, indentationStack[indentationStack.length - 1]));
        //     }
        //     indentationStack[indentationStack.length - 1] = currentIndent;
        //     if (doType === "NONE" && loopType === "WHILE") {
        //         code.push(tab() + `Loop While ${loopCondition}`);
        //     } else if (doType === "NONE" && loopType === "UNTIL") {
        //         code.push(tab() + `Loop Until ${loopCondition}`);
        //     } else {
        //         code.push(tab() + 'Loop');
        //     }
        //     code = code.join('\n') + '\n';
        //     return formatComment(block, code, indentationStack);
        // };

        // Blockly.JavaScript.forBlock['do_loop_simple'] = function (block) {
        //     var currentIndent = indentationStack[indentationStack.length - 1] || 1;
        //     indentationStack[indentationStack.length - 1] = currentIndent;
        //     var doType = block.getFieldValue('DO_TYPE');
        //     var doCondition = sanitizeCondition(block.getFieldValue('DO_CONDITION'));
        //     var loopType = block.getFieldValue('LOOP_TYPE');
        //     var loopCondition = sanitizeCondition(block.getFieldValue('LOOP_CONDITION'));
        //     var doCode = Blockly.JavaScript.statementToCode(block, 'DO_CODE') || '';
        //     var code = [];
        //     if (doType === "WHILE") {
        //         code.push(tab() + `Do While ${doCondition}`);
        //     } else if (doType === "UNTIL") {
        //         code.push(tab() + `Do Until ${doCondition}`);
        //     } else if (doType === "FOREVER") {
        //         code.push(tab() + 'Do');
        //     } else {
        //         code.push(tab() + 'Do');
        //     }
        //     indentationStack[indentationStack.length - 1]++;
        //     if (doCode.trim()) {
        //         code.push(reformatCode(doCode, indentationStack[indentationStack.length - 1]));
        //     } else {
        //         code.push(tab() + '\' No DO_CODE provided');
        //     }
        //     indentationStack[indentationStack.length - 1] = currentIndent;
        //     if (doType === "NONE" && loopType === "WHILE") {
        //         code.push(tab() + `Loop While ${loopCondition}`);
        //     } else if (doType === "NONE" && loopType === "UNTIL") {
        //         code.push(tab() + `Loop Until ${loopCondition}`);
        //     } else {
        //         code.push(tab() + 'Loop');
        //     }
        //     code = code.join('\n') + '\n';
        //     return formatComment(block, code, indentationStack);
        // };

        Blockly.JavaScript.forBlock['do_loop_simplest'] = function (block) {
            var currentIndent = indentationStack[indentationStack.length - 1] || 1;
            indentationStack[indentationStack.length - 1] = currentIndent;
            var doCode = Blockly.JavaScript.statementToCode(block, 'DO_CODE') || '';
            var code = [];
            code.push(tab() + 'Do');
            indentationStack[indentationStack.length - 1]++;
            if (doCode.trim()) {
                code.push(reformatCode(doCode, indentationStack[indentationStack.length - 1]));
            } else {
                code.push(tab() + '\' No DO_CODE provided');
            }
            indentationStack[indentationStack.length - 1] = currentIndent;
            code.push(tab() + 'Loop');
            code = code.join('\n') + '\n';
            return formatComment(block, code, indentationStack);
        };

        Blockly.JavaScript.forBlock['export_code'] = function (block) {
            return `
                            var code = Blockly.JavaScript.workspaceToCode(Blockly.getMainWorkspace());
                            var blob = new Blob([code], { type: "text/plain" });
                            var a = document.createElement("a");
                            a.href = URL.createObjectURL(blob);
                            a.download = "generated_code.js";
                            a.click();
                        `;
        };

        Blockly.JavaScript.forBlock['get_variable'] = function (block) {
            var varModel = block.getField('VAR_NAME').getVariable();
            if (!varModel) {
                console.warn(`⚠️ Variable model not found in block ID: ${block.id}`);
                return ['UNKNOWN_VAR', Blockly.JavaScript.ORDER_ATOMIC];
            }
            var varName = varModel.name;
            return [varName, Blockly.JavaScript.ORDER_ATOMIC];
        };

        Blockly.JavaScript.forBlock['import_blocks'] = function (block) {
            return `
                            document.getElementById("fileInput").click();
                            document.getElementById("fileInput").onchange = function(event) {
                                var reader = new FileReader();
                                reader.onload = function() {
                                    var xml = Blockly.Xml.textToDom(reader.result);
                                    Blockly.Xml.appendDomToWorkspace(xml, Blockly.getMainWorkspace());
                                };
                                reader.readAsText(event.target.files[0]);
                            };
                        `;
        };

        Blockly.JavaScript.forBlock['lcd_cls'] = function (block) {
            code = tab() + `CLS\n`;
            return formatComment(block, code, indentationStack);
        };

        Blockly.JavaScript.forBlock['math_modulo'] = function (block) {
            var a = Blockly.JavaScript.valueToCode(block, "A", Blockly.JavaScript.ORDER_ATOMIC) || "0";
            var b = Blockly.JavaScript.valueToCode(block, "B", Blockly.JavaScript.ORDER_ATOMIC) || "1";
            var code = a + " % " + b;
            return [code, Blockly.JavaScript.ORDER_ATOMIC];
        };

        Blockly.JavaScript.forBlock['math_number'] = function (block) {
            var number = block.getFieldValue("NUMBER");
            return [String(number), Blockly.JavaScript.ORDER_ATOMIC];
        };

        Blockly.JavaScript.forBlock['math_odd_even'] = function (block) {
            var number = Blockly.JavaScript.valueToCode(block, "NUMBER", Blockly.JavaScript.ORDER_ATOMIC) || "0";
            var check = block.getFieldValue("CHECK");
            var code = check === "ODD" ? "( " + number + " % 2 ) <> 0" : "( " + number + " % 2 ) = 0";
            //var code = check === "ODD" ? number + " % 2 !== 0" : number + " % 2 === 0";
            return [code, Blockly.JavaScript.ORDER_ATOMIC];
        };

        Blockly.JavaScript.forBlock['math_operation'] = function (block) {
            var a = Blockly.JavaScript.valueToCode(block, "A", Blockly.JavaScript.ORDER_ATOMIC) || "0";
            var b = Blockly.JavaScript.valueToCode(block, "B", Blockly.JavaScript.ORDER_ATOMIC) || "0";
            var operator = block.getFieldValue("OPERATOR");
            var code = a + " " + operator + " " + b;
            return [code, Blockly.JavaScript.ORDER_ATOMIC];
        };

        Blockly.JavaScript.forBlock['numeric_variable'] = function (block) {
            var varName = block.getFieldValue('VAR_NAME');
            var varType = block.getFieldValue('VAR_TYPE');
            var initialValue = block.getFieldValue('INITIAL_VALUE');
            let outstring = tab() + `Dim ${varName} As ${varType}\n`;
            indentationStack[indentationStack.length - 1]++;
            outstring += tab() + `${varName} = ${initialValue}\n`;
            indentationStack[indentationStack.length - 1]--;
            return outstring;
        };

        Blockly.JavaScript.forBlock['open_project'] = function (block) {
            return 'document.getElementById("fileInput").click();\n';
        };

        Blockly.JavaScript.forBlock['print_text'] = function (block) {
            var text = block.getFieldValue('TEXT') || '';
            var code = tab() + `Print ${text}\n`;
            return formatComment(block, code, indentationStack);
        };

        Blockly.JavaScript.forBlock['repeat_loop'] = function (block) {
            var currentIndent = indentationStack[indentationStack.length - 1] || 1;
            indentationStack[indentationStack.length - 1] = currentIndent;
            var repeatType = block.getFieldValue('REPEAT_TYPE');
            var repeatCount = block.getFieldValue('REPEAT_COUNT');
            var exitCondition = sanitizeCondition(block.getFieldValue('EXIT_CONDITION'));
            var repeatCode = Blockly.JavaScript.statementToCode(block, 'REPEAT_CODE') || '';
            var afterExitCode = Blockly.JavaScript.statementToCode(block, 'AFTER_EXIT_CODE') || '';
            var code = [];
            if (repeatType === "FOREVER") {
                code.push(tab() + `Repeat`);
            } else {
                var validatedCount = sanitizeRepeatCount(repeatCount);
                code.push(tab() + `Repeat ${validatedCount}`);
            }
            indentationStack[indentationStack.length - 1]++;
            if (repeatCode.trim()) {
                code.push(reformatCode(repeatCode, indentationStack[indentationStack.length - 1]));
            } else {
                code.push(tab() + '\' No REPEAT_CODE provided');
            }
            if (exitCondition && exitCondition !== 'true' && exitCondition !== 'false') {
                code.push(tab() + `If ${exitCondition} Then Exit Repeat`);
            } else if (exitCondition === 'true') {
                code.push(tab() + 'Exit Repeat');
            }
            if (afterExitCode.trim()) {
                code.push(reformatCode(afterExitCode, indentationStack[indentationStack.length - 1]));
            }
            indentationStack[indentationStack.length - 1] = currentIndent;
            code.push(tab() + 'End Repeat');
            code = code.join('\n') + '\n';
            return formatComment(block, code, indentationStack);
        };

        Blockly.JavaScript.forBlock['repeat_loop_simple'] = function (block) {
            var currentIndent = indentationStack[indentationStack.length - 1] || 1;
            indentationStack[indentationStack.length - 1] = currentIndent;
            var repeatType = block.getFieldValue('REPEAT_TYPE');
            var repeatCount = block.getFieldValue('REPEAT_COUNT');
            var repeatCode = Blockly.JavaScript.statementToCode(block, 'REPEAT_CODE') || '';
            var code = [];
            if (repeatType === "FOREVER") {
                code.push(tab() + `Repeat`);
            } else {
                var validatedCount = sanitizeRepeatCount(repeatCount);
                code.push(tab() + `Repeat ${validatedCount}`);
            }
            indentationStack[indentationStack.length - 1]++;
            if (repeatCode.trim()) {
                code.push(reformatCode(repeatCode, indentationStack[indentationStack.length - 1]));
            } else {
                code.push(tab() + '\' No REPEAT_CODE provided');
            }
            indentationStack[indentationStack.length - 1] = currentIndent;
            code.push(tab() + 'End Repeat');
            code = code.join('\n') + '\n';
            return formatComment(block, code, indentationStack);
        };

        Blockly.JavaScript.forBlock['reset_workspace'] = function (block) {
            return `
                            if (confirm("Are you sure you want to clear all blocks?")) {
                                Blockly.getMainWorkspace().clear();
                            }
                        `;
        };

        Blockly.JavaScript.forBlock['save_project'] = function (block) {
            return `
                            var xml = Blockly.Xml.workspaceToDom(Blockly.getMainWorkspace());
                            var xmlText = Blockly.Xml.domToText(xml);
                            var blob = new Blob([xmlText], { type: "text/xml" });
                            var a = document.createElement("a");
                            a.href = URL.createObjectURL(blob);
                            a.download = "blockly_project.xml";
                            a.click();
                        `;
        };

        Blockly.JavaScript.forBlock['select_chip'] = function (block) {
            try {
                const chip = block.getFieldValue('CHIP');
                const chipInfo = chipData.find(c => c.name === chip);
                return `#chip ${chip}, ${chipInfo ? chipInfo.clock : 20}\n#option explicit\n\n`;
            } catch (e) {
                console.error('DEBUG: Error in select_chip generator:', e);
                return '// Error in chip selection\n';
            }
        };

        Blockly.JavaScript.forBlock['set_variable'] = function (block) {
            var varModel = block.getField('VAR_NAME').getVariable();
            if (!varModel) {
                console.warn(`⚠️ Variable model not found in block ID: ${block.id}`);
                return 'UNKNOWN_VAR = 0;\n';
            }
            var varName = varModel.name;
            var value = Blockly.JavaScript.valueToCode(block, 'VALUE', Blockly.JavaScript.ORDER_ASSIGNMENT) || '0';
            var code = tab() + `${varName} = ${value}\n`;
            return formatComment(block, code, indentationStack);

        };

        Blockly.JavaScript.forBlock['string_variable'] = function (block) {
            var varName = block.getFieldValue('VAR_NAME');
            var length = block.getFieldValue('LENGTH');
            var initialValue = Blockly.JavaScript.quote_(block.getFieldValue('INITIAL_VALUE'));
            let trimmed = initialValue.trim();
            if (trimmed.startsWith(`'"`) && trimmed.length > 1) {
                trimmed = trimmed.substring(1);
            }
            if (trimmed.endsWith(`"'`) && trimmed.length > 1) {
                trimmed = trimmed.substring(0, trimmed.length - 1);
            }
            if (trimmed.length > 1 && (!trimmed.startsWith(`"`) || !trimmed.endsWith(`"`))) {
                logToWebPageErrors(`⚠️ String formatting issue: Expected starting and ending quote. Received: "${trimmed}\n"`, "ERROR");
            }
            if (trimmed.length === 1) {
                logToWebPageErrors(`⚠️ String formatting issue: Expected starting and ending quote. Received: "${trimmed}\n"`, "ERROR");
            }
            var code = tab() + `Dim ${varName} As String * ${length}\n` + tab() + `${varName} = ${trimmed}\n`;
            return formatComment(block, code, indentationStack);
        };

        Blockly.JavaScript.forBlock['variable_block_group'] = function (block) {
            var innerBlocksCode = Blockly.JavaScript.statementToCode(block, 'INNER_BLOCKS');
            return `${innerBlocksCode}`;
        };

        Blockly.JavaScript.forBlock['wait_100ms'] = function (block) {
            var code = tab() + `wait 100 ms\n`;
            return formatComment(block, code, indentationStack);
        };

        Blockly.JavaScript.forBlock['wait_conditional'] = function (block) {
            var condition = Blockly.JavaScript.valueToCode(block, 'CONDITION', Blockly.JavaScript.ORDER_ATOMIC) || 'true';
            var mode = block.getFieldValue('MODE');
            var code = tab() + `Wait ${mode} ${condition}\n`;
            return formatComment(block, code, indentationStack);
        };

        Blockly.JavaScript.forBlock['wait_fixed'] = function (block) {
            var value = Blockly.JavaScript.valueToCode(block, 'DELAY_VALUE', Blockly.JavaScript.ORDER_ATOMIC) || block.getFieldValue('VALUE');
            var unit = block.getFieldValue('UNIT');

            // Generate the base code line
            var code = tab() + `Wait ${value} ${unit}\n`;

            // Format comment and return
            return formatComment(block, code, indentationStack);
        };

        // Other Functions

        function addBackgroundImage(imagePath = "GCstudio.png", duration = 10000) {
            // Check if on mobile device and disable background image
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            if (isMobile) {
                return false;
            }

            if (!workspace) {
                logToWebPageErrors("Error: Workspace not initialized for background image.\n", "ERROR");
                return false;
            }

            const svg = workspace.getInjectionDiv().querySelector('svg');
            if (!svg) {
                logToWebPageErrors("Error: Failed to add background image - SVG not found.\n", "ERROR");
                return false;
            }

            const blocklyDiv = document.getElementById('blocklyDiv');
            if (!blocklyDiv) {
                logToWebPageErrors("Error: BlocklyDiv not found for background image sizing.\n", "ERROR");
                return false;
            }

            const img = new Image();
            img.onload = () => {
                const backgroundImage = document.createElementNS("http://www.w3.org/2000/svg", "image");
                const blocklyRect = blocklyDiv.getBoundingClientRect();
                const viewportWidth = window.innerWidth;
                const maxHeight = blocklyRect.height;

                const aspectRatio = img.width / img.height;
                let width = viewportWidth * 0.9; // Initial width at 90% of viewport
                let height = width / aspectRatio; // Initial height based on aspect ratio

                // Adjust if height exceeds maxHeight
                if (height > maxHeight) {
                    height = maxHeight;
                    width = height * aspectRatio;
                }

                // Reduce to 50% of calculated size
                width = width * 0.75;
                height = height * 0.75;

                // Recalculate offsets to keep the image centered
                const xOffset = (blocklyRect.width - width) / 2;
                const yOffset = (maxHeight - height) / 2;

                backgroundImage.setAttributeNS(null, "href", imagePath);
                backgroundImage.setAttributeNS(null, "width", `${width}px`);
                backgroundImage.setAttributeNS(null, "height", `${height}px`);
                backgroundImage.setAttributeNS(null, "preserveAspectRatio", "xMidYMid meet");
                backgroundImage.setAttributeNS(null, "opacity", "1");
                backgroundImage.setAttributeNS(null, "x", `${xOffset}px`);
                backgroundImage.setAttributeNS(null, "y", `${yOffset}px`);
                svg.insertBefore(backgroundImage, svg.firstChild);

                setTimeout(() => {
                    backgroundImage.remove();
                }, duration);
                return true;
            };
            img.onerror = () => {
                logToWebPageErrors(`Error: Background image '${imagePath}' failed to load.\n`, "ERROR");
                return false;
            };
            img.src = imagePath;
            return false;
        }
        function clearConsole(e) {
            if (e) e.stopPropagation();
            var consoleDiv = document.getElementById("webpageconsole");
            if (consoleDiv) {
                consoleDiv.innerHTML = "";
            }
        }

        function clearErrors(e) {
            if (e) e.stopPropagation();
            var errorDiv = document.getElementById("WebPageErrors");
            if (errorDiv) {
                errorDiv.innerHTML = "";
            }
        }

        function copyConsole(e) {
            if (e) e.stopPropagation();
            try {
                const consoleDiv = document.getElementById('webpageconsole');
                const copyButton = document.getElementById('copyConsoleButton');
                const consoleText = Array.from(consoleDiv.childNodes)
                    .map(node => node.nodeType === Node.TEXT_NODE ? node.textContent : node.innerText)
                    .join('\n');
                navigator.clipboard.writeText(consoleText).then(() => {
                    copyButton.textContent = 'Copied!';
                    copyButton.classList.add('copied');
                    setTimeout(() => {
                        copyButton.textContent = 'Copy';
                        copyButton.classList.remove('copied');
                    }, 2000);
                }).catch(err => {
                    console.warn('Clipboard API failed:', err);
                    try {
                        const textarea = document.createElement('textarea');
                        textarea.value = consoleText;
                        textarea.style.position = 'fixed';
                        textarea.style.opacity = '0';
                        document.body.appendChild(textarea);
                        textarea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textarea);
                        copyButton.textContent = 'Copied!';
                        copyButton.classList.add('copied');
                        setTimeout(() => {
                            copyButton.textContent = 'Copy';
                            copyButton.classList.remove('copied');
                        }, 2000);
                    } catch (fallbackErr) {
                        console.error('Failed to copy console content:', fallbackErr);
                        copyButton.textContent = 'Copy Failed!';
                        copyButton.classList.add('error');
                        setTimeout(() => {
                            copyButton.textContent = 'Copy';
                            copyButton.classList.remove('error');
                        }, 2000);
                        logToWebPageErrors("Error: Failed to copy console content. Please select and copy manually.\n", "ERROR");
                    }
                });
            } catch (e) {
                console.error('Error in copyConsole:', e);
                logToWebPageErrors("Error: Failed to copy console content due to script error.\n", "ERROR");
            }
        }

        function exportCode() {
            var code = Blockly.JavaScript.workspaceToCode(Blockly.getMainWorkspace());
            var blob = new Blob([code], { type: "text/plain" });
            var a = document.createElement("a");
            a.href = URL.createObjectURL(blob);
            a.download = "generated_code.gcb";
            a.click();
        }

        function filterChips() {
            const searchText = document.getElementById('chipSearch').value.toLowerCase();
            const select = document.getElementById('chipSelect');
            for (let option of select.options) {
                option.style.display = option.value.toLowerCase().includes(searchText) || option.value === "" ? "block" : "none";
            }
        }

        function formatComment(block, code, indentationStack) {
            var commentText = block.getCommentText();

            if (commentText) {
                // Strip all leading and trailing \n from the comment
                commentText = commentText.replace(/^\n+/, '').replace(/\n+$/, '');

                // Count the number of \n in the comment
                var newlineCount = (commentText.match(/\n/g) || []).length;

                if (newlineCount === 0) {
                    // Single-line comment
                    var formattedComment = `${tab()}// ${commentText}\n`;
                    code = formattedComment + code;
                } else {
                    // Multi-line comment
                    var currentIndentLevel = indentationStack[indentationStack.length - 1] || 0;

                    var lines = commentText.split('\n');
                    var formattedComment = `${tab()}/*\n`;
                    indentationStack[indentationStack.length - 1] = currentIndentLevel + 1; // Increment tabcounter
                    for (let i = 0; i < lines.length; i++) {
                        if (i < lines.length - 1) {
                            formattedComment += `${tab()}${lines[i]}\n`; // All lines except last with \n
                        } else {
                            formattedComment += `${tab()}${lines[i]}\n`; // Last line with \n
                        }
                    }
                    formattedComment += `${tab()}*/\n`;
                    indentationStack[indentationStack.length - 1] = currentIndentLevel; // Decrement tabcounter
                    code = formattedComment + code;
                }
            }

            return code;
        }

    // Revised handleFileSelect function
    function handleFileSelect(event) {
    var file = event.target.files[0];
    if (!file) {
        console.error("ERROR: No file selected!");
        return;
    }

    var reader = new FileReader();
    reader.onload = function () {
        try {
            console.clear();
            console.log("DEBUG: Starting import process...");

            var tempXml = Blockly.utils.xml.textToDom(reader.result);
            var workspace = Blockly.getMainWorkspace();
            workspace.clear();

            // Step 1: Cache 'create_list', 'set_constant_state', and 'get_numeric_constant' blocks
            console.log("DEBUG: Extracting 'create_list', 'set_constant_state', and 'get_numeric_constant' blocks...");
            let createListBlocks = Array.from(tempXml.getElementsByTagName("block")).filter(block =>
                block.getAttribute("type") === "create_list"
            );
            let setConstantBlocks = Array.from(tempXml.getElementsByTagName("block")).filter(block =>
                block.getAttribute("type") === "set_constant_state"
            );
            let getNumericConstantBlocks = Array.from(tempXml.getElementsByTagName("block")).filter(block =>
                block.getAttribute("type") === "get_numeric_constant"
            );

            // Cache CONSTANT_NAME values and block IDs for set_constant_state blocks
            let constantNameCache = setConstantBlocks.map(block => ({
                id: block.getAttribute("id"),
                name: Array.from(block.getElementsByTagName("field")).find(f =>
                    f.getAttribute("name") === "CONSTANT_NAME"
                )?.textContent || null
            })).filter(item => item.name);

            // Cache CONSTANT_NAME values and block IDs for get_numeric_constant blocks
            let numericConstantNameCache = getNumericConstantBlocks.map(block => ({
                id: block.getAttribute("id"),
                name: Array.from(block.getElementsByTagName("field")).find(f =>
                    f.getAttribute("name") === "CONSTANT_NAME"
                )?.textContent || null
            })).filter(item => item.name);

            console.log(`DEBUG: Cached ${createListBlocks.length} 'create_list' blocks, ${constantNameCache.length} 'set_constant_state' CONSTANT_NAME values, and ${numericConstantNameCache.length} 'get_numeric_constant' CONSTANT_NAME values.`);

            // Step 2: Process 'create_list' blocks with XY positions
            createListBlocks.forEach(block => {
                try {
                    let x = parseFloat(block.getAttribute("x")) || 50;
                    let y = parseFloat(block.getAttribute("y")) || 50;

                    const tempXmlDoc = document.createElement('xml');
                    const clonedBlock = block.cloneNode(true);
                    tempXmlDoc.appendChild(clonedBlock);

                    Blockly.Xml.domToWorkspace(tempXmlDoc, workspace);

                    const blockId = clonedBlock.getAttribute("id");
                    let newBlock = blockId ? workspace.getBlockById(blockId) : workspace.getAllBlocks().find(b => b.type === "create_list" && !b.isInFlyout());
                    if (newBlock) {
                        newBlock.moveBy(x, y);
                    }

                    block.parentNode.removeChild(block);
                } catch (error) {
                    console.error("ERROR: Failed to process 'create_list' block:", error);
                }
            });

            // Step 3: Append remaining blocks
            console.log("DEBUG: Importing remaining blocks...");
            Blockly.Xml.appendDomToWorkspace(tempXml, workspace);
            console.log("DEBUG: Remaining blocks imported successfully!");

            // Step 4: Validate 'read_table' dropdowns & fix missing table references
            console.log("DEBUG: Validating 'read_table' dropdowns...");
            let listBlocks = workspace.getBlocksByType("create_list", false);
            let validTables = listBlocks.map(block => block.getFieldValue("LIST_NAME"));
            let tableBlocks = workspace.getBlocksByType("read_table", false);
            tableBlocks.forEach(block => {
                let tableNameField = block.getField("TABLE_NAME");
                if (tableNameField && !validTables.includes(tableNameField.getValue())) {
                    block.setWarningText("Error: Referenced table does not exist!", "TABLE_MISSING");
                    block.setColour("#FF0000");
                    tableNameField.setValue(validTables[0] || "");
                    console.log(`DEBUG: Updated 'read_table' block to valid table: ${validTables[0] || "None Found"}`);
                } else {
                    block.setWarningText(null);
                    block.setColour("#D4A017");
                }
            });

            // Step 5: Validate 'set_constant_state' and 'get_numeric_constant' dropdowns & restore cached CONSTANT_NAME values
            console.log("DEBUG: Validating 'set_constant_state' and 'get_numeric_constant' dropdowns...");
            setTimeout(() => {
                let constantBlocks = workspace.getBlocksByType("define_constant", false);
                let validConstants = constantBlocks
                    .filter(block => {
                        let value = block.getFieldValue("VALUE")?.trim();
                        return value && !value.match(/^(?:\d+|(0x|0X)[0-9A-Fa-f]+|(0b|0B)[01]+)$/i);
                    })
                    .map(block => block.getFieldValue("NAME").toUpperCase().trim());
                let validNumericConstants = constantBlocks
                    .filter(block => {
                        let value = block.getFieldValue("VALUE")?.trim();
                        return value && value.match(/^(?:\d+|(0x|0X)[0-9A-Fa-f]+|(0b|0B)[01]+)$/i);
                    })
                    .map(block => block.getFieldValue("NAME").toUpperCase().trim());

                // Validate set_constant_state blocks
                let setConstantStateBlocks = workspace.getBlocksByType("set_constant_state", false);
                setConstantStateBlocks.forEach(block => {
                    let constantNameField = block.getField("CONSTANT_NAME");
                    let cachedEntry = constantNameCache.find(entry => entry.id === block.id);
                    let cachedName = cachedEntry ? cachedEntry.name : constantNameField.getValue();
                    if (constantNameField && !validConstants.includes(cachedName)) {
                        block.setWarningText("Error: Referenced constant does not exist or is numeric!", "CONSTANT_MISSING");
                        block.setColour("#FF0000");
                        constantNameField.setValue(validConstants[0] || "");
                        console.log(`DEBUG: Updated 'set_constant_state' block to valid constant: ${validConstants[0] || "None Found"}`);
                    } else {
                        block.setWarningText(null);
                        block.setColour(160);
                        if (cachedName && validConstants.includes(cachedName)) {
                            constantNameField.setValue(cachedName);
                            console.log(`DEBUG: Restored 'set_constant_state' block CONSTANT_NAME to: ${cachedName}`);
                        }
                    }
                    // Force dropdown refresh
                    constantNameField.setValue(constantNameField.getValue());
                });

                // Validate get_numeric_constant blocks
                let getNumericConstantStateBlocks = workspace.getBlocksByType("get_numeric_constant", false);
                getNumericConstantStateBlocks.forEach(block => {
                    let constantNameField = block.getField("CONSTANT_NAME");
                    let cachedEntry = numericConstantNameCache.find(entry => entry.id === block.id);
                    let cachedName = cachedEntry ? cachedEntry.name : constantNameField.getValue();
                    if (constantNameField && !validNumericConstants.includes(cachedName)) {
                        block.setWarningText("Error: Selected numeric constant does not exist!", "CONSTANT_MISSING");
                        block.setColour("#FF0000");
                        constantNameField.setValue(validNumericConstants[0] || "");
                        console.log(`DEBUG: Updated 'get_numeric_constant' block to valid constant: ${validNumericConstants[0] || "None Found"}`);
                    } else {
                        block.setWarningText(null);
                        block.setColour(160);
                        if (cachedName && validNumericConstants.includes(cachedName)) {
                            constantNameField.setValue(cachedName);
                            console.log(`DEBUG: Restored 'get_numeric_constant' block CONSTANT_NAME to: ${cachedName}`);
                        }
                    }
                    // Force dropdown refresh
                    constantNameField.setValue(constantNameField.getValue());
                });

                // Step 6: Initialize code generator
                Blockly.JavaScript.init(workspace);
                console.log("DEBUG: Code generator initialized successfully!");
            }, 300); // Increased delay to ensure all blocks are rendered
        } catch (error) {
            console.error("ERROR: Parsing XML failed!", error);
            console.error("DEBUG: Received XML content:", reader.result);
            logToWebPageErrors(`Error: Failed to parse XML: ${error.message}\n`, "ERROR");
        }
    };

    reader.readAsText(file);
}


        // before trying to resolve loading of constants.
        // function handleFileSelect(event) {
        //     var file = event.target.files[0];
        //     if (!file) {
        //         console.error("ERROR: No file selected! @ 1");
        //         return;
        //     }
        //     var reader = new FileReader();
        //     reader.onload = function () {
        //         try {
        //             console.clear(); // Clear previous logs for clean debugging
        //             console.log("DEBUG: Starting import process...");

        //             var tempXml = Blockly.utils.xml.textToDom(reader.result);
        //             var workspace = Blockly.getMainWorkspace();
        //             workspace.clear(); // Ensure fresh workspace

        //             console.log("DEBUG: Extracting 'create_list' blocks...");
        //             let createListBlocks = Array.from(tempXml.getElementsByTagName("block")).filter(block =>
        //                 block.getAttribute("type") === "create_list"
        //             );

        //             createListBlocks.forEach(block => Blockly.Xml.domToWorkspace(block, workspace));
        //             console.log(`DEBUG: Imported ${createListBlocks.length} 'create_list' blocks.`);

        //             // Verify that 'create_list' exists before proceeding
        //             let listBlocks = workspace.getBlocksByType("create_list", false);
        //             if (listBlocks.length === 0) {
        //                 console.error("ERROR: No 'create_list' blocks found after import. Aborting!");
        //                 return;
        //             }

        //             console.log("DEBUG: 'create_list' blocks are present in the workspace. Proceeding with the rest of the XML...");

        //             // Force workspace refresh before loading the remaining blocks
        //             Blockly.getMainWorkspace().resize();

        //             // Step 2: Append remaining blocks separately (avoiding duplicate 'create_list' imports)
        //             Blockly.Xml.appendDomToWorkspace(tempXml, workspace);
        //             console.log("DEBUG: Remaining blocks imported successfully!");

        //             // Step 3: Validate 'read_table' dropdowns & fix missing table references
        //             let validTables = listBlocks.map(block => block.getFieldValue("LIST_NAME"));

        //             let tableBlocks = workspace.getBlocksByType("read_table", false);
        //             tableBlocks.forEach(block => {
        //                 let tableNameField = block.getField("TABLE_NAME");

        //                 if (tableNameField && !validTables.includes(tableNameField.getValue())) {
        //                     block.setWarningText("Error: Referenced table does not exist!", "TABLE_MISSING");
        //                     block.setColour("#FF0000");
        //                     tableNameField.setValue(validTables[0] || ""); // Assign first valid table
        //                     console.log(`DEBUG: Updated dropdown in 'read_table' block to valid table: ${validTables[0] || "None Found"}`);
        //                 } else {
        //                     block.setWarningText(null);
        //                     block.setColour("#D4A017");
        //                 }
        //             });

        //             console.log("DEBUG: Ensured 'read_table' dropdown references only valid tables.");

        //             // Step 4: Delay Blockly CodeGenerator initialization until all blocks are fully restored
        //             setTimeout(() => {
        //                 Blockly.JavaScript.init(workspace);
        //                 console.log("DEBUG: Code generator initialized successfully!");
        //             }, 150);

        //         } catch (error) {
        //             console.error("ERROR: Parsing XML failed!", error);
        //             console.error("DEBUG: Received XML content:", reader.result);
        //         }
        //     };

        //     reader.readAsText(file);
        // }



    // 1506

    function importBlocks() {
        var fileInput = document.getElementById("fileInput");
        if (!fileInput) {
            logToWebPageErrors("Error: File input element not found!\n", "ERROR");
            return;
        }
        fileInput.value = "";
        fileInput.onchange = function (event) {
            var file = event.target.files[0];
            if (!file) {
                return;
            }
            loadXml(file, false, () => {
                logToWebPageErrors("Blocks imported successfully!\n", "INFO");
            });
        };
        fileInput.click();
        }

    // // Revised importBlocks function
    // function importBlocks() {
    //         var fileInput = document.getElementById("fileInput");
    //         if (!fileInput) {
    //             logToWebPageErrors("Error: File input element not found!\n", "ERROR");
    //             return;
    //         }
    //         fileInput.value = "";
    //         fileInput.onchange = function (event) {
    //             var file = event.target.files[0];
    //             if (!file) {
    //                 return;
    //             }

    //             var reader = new FileReader();
    //             reader.onload = function () {
    //                 try {
    //                     var tempXml = Blockly.utils.xml.textToDom(reader.result);
    //                     var workspace = Blockly.getMainWorkspace();

    //                     // Step 1: Cache 'create_list', 'set_constant_state', and 'get_numeric_constant' blocks
    //                     let createListBlocks = Array.from(tempXml.getElementsByTagName("block")).filter(block =>
    //                         block.getAttribute("type") === "create_list"
    //                     );
    //                     let setConstantBlocks = Array.from(tempXml.getElementsByTagName("block")).filter(block =>
    //                         block.getAttribute("type") === "set_constant_state"
    //                     );
    //                     let getNumericConstantBlocks = Array.from(tempXml.getElementsByTagName("block")).filter(block =>
    //                         block.getAttribute("type") === "get_numeric_constant"
    //                     );

    //                     // Cache CONSTANT_NAME values and block IDs for set_constant_state blocks
    //                     let constantNameCache = setConstantBlocks.map(block => ({
    //                         id: block.getAttribute("id"),
    //                         name: Array.from(block.getElementsByTagName("field")).find(f =>
    //                             f.getAttribute("name") === "CONSTANT_NAME"
    //                         )?.textContent || null
    //                     })).filter(item => item.name);

    //                     // Cache CONSTANT_NAME values and block IDs for get_numeric_constant blocks
    //                     let numericConstantNameCache = getNumericConstantBlocks.map(block => ({
    //                         id: block.getAttribute("id"),
    //                         name: Array.from(block.getElementsByTagName("field")).find(f =>
    //                             f.getAttribute("name") === "CONSTANT_NAME"
    //                         )?.textContent || null
    //                     })).filter(item => item.name);

    //                     // Step 2: Process 'create_list' blocks with XY positions
    //                     createListBlocks.forEach(block => {
    //                         try {
    //                             let x = parseFloat(block.getAttribute("x")) || 50;
    //                             let y = parseFloat(block.getAttribute("y")) || 50;

    //                             const tempXmlDoc = document.createElement('xml');
    //                             const clonedBlock = block.cloneNode(true);
    //                             tempXmlDoc.appendChild(clonedBlock);

    //                             Blockly.Xml.domToWorkspace(tempXmlDoc, workspace);

    //                             const blockId = clonedBlock.getAttribute("id");
    //                             let newBlock = blockId ? workspace.getBlockById(blockId) : workspace.getAllBlocks().find(b => b.type === "create_list" && !b.isInFlyout());
    //                             if (newBlock) {
    //                                 newBlock.moveBy(x, y);
    //                             }

    //                             block.parentNode.removeChild(block);
    //                         } catch (error) {
    //                             logToWebPageErrors(`Error: Failed to process 'create_list' block: ${error.message}\n`, "ERROR");
    //                         }
    //                     });

    //                     // Step 3: Append remaining blocks
    //                     workspace.getBlocksByType("set_constant_state", false).forEach(block => {
    //                         block.isLoading = true;
    //                     });
    //                     Blockly.Xml.appendDomToWorkspace(tempXml, workspace);

    //                     // Step 4: Validate 'read_table' dropdowns & fix missing table references
    //                     let listBlocks = workspace.getBlocksByType("create_list", false);
    //                     let validTables = listBlocks.map(block => block.getFieldValue("LIST_NAME"));
    //                     let tableBlocks = workspace.getBlocksByType("read_table", false);
    //                     tableBlocks.forEach(block => {
    //                         let tableNameField = block.getField("TABLE_NAME");
    //                         if (tableNameField && !validTables.includes(tableNameField.getValue())) {
    //                             block.setWarningText("Error: Referenced table does not exist!", "TABLE_MISSING");
    //                             block.setColour("#FF0000");
    //                             tableNameField.setValue(validTables[0] || "");
    //                         } else {
    //                             block.setWarningText(null);
    //                             block.setColour("#D4A017");
    //                         }
    //                     });

    //                     // Step 5: Validate 'set_constant_state' and 'get_numeric_constant' dropdowns & restore cached CONSTANT_NAME values
    //                     function validateConstants(retryCount = 0) {
    //                         let constantBlocks = workspace.getBlocksByType("define_constant", false);
    //                         let validConstants = constantBlocks
    //                             .filter(block => {
    //                                 let value = block.getFieldValue("VALUE")?.trim();
    //                                 return value && !value.match(/^(?:\d+|(0x|0X)[0-9A-Fa-f]+|(0b|0B)[01]+)$/i);
    //                             })
    //                             .map(block => block.getFieldValue("NAME").toUpperCase().trim());
    //                         let validNumericConstants = constantBlocks
    //                             .filter(block => {
    //                                 let value = block.getFieldValue("VALUE")?.trim();
    //                                 return value && value.match(/^(?:\d+|(0x|0X)[0-9A-Fa-f]+|(0b|0B)[01]+)$/i);
    //                             })
    //                             .map(block => block.getFieldValue("NAME").toUpperCase().trim());
    //                         let allValid = true;

    //                         // Validate set_constant_state blocks
    //                         let setConstantStateBlocks = workspace.getBlocksByType("set_constant_state", false);
    //                         setConstantStateBlocks.forEach(block => {
    //                             let constantNameField = block.getField("CONSTANT_NAME");
    //                             let cachedEntry = constantNameCache.find(entry => entry.id === block.id);
    //                             let cachedName = cachedEntry ? cachedEntry.name : constantNameField.getValue();
    //                             block.isLoading = false;
    //                             if (constantNameField && validConstants.includes(cachedName)) {
    //                                 block.forceSetValue(cachedName);
    //                                 console.log(`Restored constant ${cachedName} for set_constant_state block`);
    //                                 block.setWarningText(null);
    //                                 block.setColour(160);
    //                             } else {
    //                                 allValid = false;
    //                                 block.setWarningText("Error: Referenced constant does not exist or is numeric!", "CONSTANT_MISSING");
    //                                 block.setColour("#FF0000");
    //                                 block.forceSetValue(validConstants[0] || "");
    //                             }
    //                             constantNameField.setValue(constantNameField.getValue());
    //                         });

    //                         // Validate get_numeric_constant blocks
    //                         let getNumericConstantStateBlocks = workspace.getBlocksByType("get_numeric_constant", false);
    //                         getNumericConstantStateBlocks.forEach(block => {
    //                             let constantNameField = block.getField("CONSTANT_NAME");
    //                             let cachedEntry = numericConstantNameCache.find(entry => entry.id === block.id);
    //                             let cachedName = cachedEntry ? cachedEntry.name : constantNameField.getValue();
    //                             block.isLoading = false;
    //                             if (constantNameField && validNumericConstants.includes(cachedName)) {
    //                                 block.forceSetValue(cachedName);
    //                                 console.log(`Restored constant ${cachedName} for get_numeric_constant block`);
    //                                 block.setWarningText(null);
    //                                 block.setColour(160);
    //                             } else {
    //                                 allValid = false;
    //                                 block.setWarningText("Error: Selected numeric constant does not exist!", "CONSTANT_MISSING");
    //                                 block.setColour("#FF0000");
    //                                 block.forceSetValue(validNumericConstants[0] || "");
    //                             }
    //                             constantNameField.setValue(constantNameField.getValue());
    //                         });

    //                         if (!allValid && retryCount < 2) {
    //                             setTimeout(() => validateConstants(retryCount + 1), 500);
    //                             return;
    //                         }

    //                         // Step 6: Initialize code generator
    //                         Blockly.JavaScript.init(workspace);
    //                         workspace.render();
    //                         Blockly.svgResize(workspace);
    //                         logToWebPageErrors("Blocks successfully imported!\n", "INFO");
    //                     }

    //                     workspace.render();
    //                     setTimeout(() => validateConstants(), 750);
    //                 } catch (error) {
    //                     logToWebPageErrors(`Error: Failed to parse XML: ${error.message}\n`, "ERROR");
    //                 }
    //             };
    //             reader.readAsText(file);
    //         };
    //         fileInput.click();
    //     }

        // pre load Constants
        // function importBlocks() {
        //     var fileInput = document.getElementById("fileInput");
        //     if (!fileInput) {
        //         console.error("File input not found!");
        //         return;
        //     }
        //     fileInput.value = "";
        //     fileInput.onchange = function (event) {
        //         var reader = new FileReader();
        //         reader.onload = function () {
        //             try {
        //                 var xml = Blockly.utils.xml.textToDom(reader.result);
        //                 var workspace = Blockly.getMainWorkspace();
        //                 Blockly.Xml.appendDomToWorkspace(xml, workspace);
        //                 console.log("Blocks successfully imported!");
        //             } catch (error) {
        //                 console.error("Error importing XML:", error);
        //                 console.error("Received XML:", reader.result);
        //             }
        //         };
        //         reader.readAsText(event.target.files[0]);
        //     };
        //     fileInput.click();
        // }

        // Consolidated function to load XML into the workspace
        function loadXml(xmlSource, clearWorkspace = true, callback = null) {
            let xmlTextPromise;

            // Determine the source of the XML (file or text)
            if (typeof xmlSource === 'string') {
                // XML from URL or default file
                const fileUrl = new URL(xmlSource, window.location.href).href;
                xmlTextPromise = fetch(fileUrl)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! Status: ${response.status}. Ensure ${xmlSource} is accessible.`);
                        }
                        return response.text();
                    });
            } else if (xmlSource instanceof File) {
                // XML from file input
                xmlTextPromise = new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = () => reject(new Error('Failed to read file.'));
                    reader.readAsText(xmlSource);
                });
            } else {
                logToWebPageErrors("Error: Invalid XML source.\n", "ERROR");
                return;
            }

            xmlTextPromise
                .then(xmlText => {
                    try {
                        console.clear();
                        console.log("DEBUG: Starting XML load process...");

                        const tempXml = Blockly.utils.xml.textToDom(xmlText);
                        const workspace = Blockly.getMainWorkspace();

                        if (clearWorkspace) {
                            workspace.clear();
                        }

                        // Step 1: Cache 'create_list', 'set_constant_state', and 'get_numeric_constant' blocks
                        console.log("DEBUG: Extracting 'create_list', 'set_constant_state', and 'get_numeric_constant' blocks...");
                        let createListBlocks = Array.from(tempXml.getElementsByTagName("block")).filter(block =>
                            block.getAttribute("type") === "create_list"
                        );
                        let setConstantBlocks = Array.from(tempXml.getElementsByTagName("block")).filter(block =>
                            block.getAttribute("type") === "set_constant_state"
                        );
                        let getNumericConstantBlocks = Array.from(tempXml.getElementsByTagName("block")).filter(block =>
                            block.getAttribute("type") === "get_numeric_constant"
                        );

                        // Cache CONSTANT_NAME values and block IDs
                        let constantNameCache = setConstantBlocks.map(block => ({
                            id: block.getAttribute("id"),
                            name: Array.from(block.getElementsByTagName("field")).find(f =>
                                f.getAttribute("name") === "CONSTANT_NAME"
                            )?.textContent || null
                        })).filter(item => item.name);

                        let numericConstantNameCache = getNumericConstantBlocks.map(block => ({
                            id: block.getAttribute("id"),
                            name: Array.from(block.getElementsByTagName("field")).find(f =>
                                f.getAttribute("name") === "CONSTANT_NAME"
                            )?.textContent || null
                        })).filter(item => item.name);

                        console.log(`DEBUG: Cached ${createListBlocks.length} 'create_list' blocks, ${constantNameCache.length} 'set_constant_state' CONSTANT_NAME values, and ${numericConstantNameCache.length} 'get_numeric_constant' CONSTANT_NAME values.`);

                        // Step 2: Process 'create_list' blocks with XY positions
                        createListBlocks.forEach(block => {
                            try {
                                let x = parseFloat(block.getAttribute("x")) || 50;
                                let y = parseFloat(block.getAttribute("y")) || 50;

                                const tempXmlDoc = document.createElement('xml');
                                const clonedBlock = block.cloneNode(true);
                                tempXmlDoc.appendChild(clonedBlock);

                                Blockly.Xml.domToWorkspace(tempXmlDoc, workspace);

                                const blockId = clonedBlock.getAttribute("id");
                                let newBlock = blockId ? workspace.getBlockById(blockId) : workspace.getAllBlocks().find(b => b.type === "create_list" && !b.isInFlyout());
                                if (newBlock) {
                                    newBlock.moveBy(x, y);
                                }

                                block.parentNode.removeChild(block);
                            } catch (error) {
                                console.error("ERROR: Failed to process 'create_list' block:", error);
                                logToWebPageErrors(`Error: Failed to process 'create_list' block: ${error.message}\n`, "ERROR");
                            }
                        });

                        // Step 3: Append remaining blocks
                        console.log("DEBUG: Importing remaining blocks...");
                        workspace.getBlocksByType("set_constant_state", false).forEach(block => {
                            block.isLoading = true;
                        });
                        Blockly.Xml.appendDomToWorkspace(tempXml, workspace);
                        console.log("DEBUG: Remaining blocks imported successfully!");

                        // Step 4: Validate 'read_table' dropdowns
                        console.log("DEBUG: Validating 'read_table' dropdowns...");
                        let listBlocks = workspace.getBlocksByType("create_list", false);
                        let validTables = listBlocks.map(block => block.getFieldValue("LIST_NAME"));
                        let tableBlocks = workspace.getBlocksByType("read_table", false);
                        tableBlocks.forEach(block => {
                            let tableNameField = block.getField("TABLE_NAME");
                            if (tableNameField && !validTables.includes(tableNameField.getValue())) {
                                block.setWarningText("Error: Referenced table does not exist!", "TABLE_MISSING");
                                block.setColour("#FF0000");
                                tableNameField.setValue(validTables[0] || "");
                                console.log(`DEBUG: Updated 'read_table' block to valid table: ${validTables[0] || "None Found"}`);
                            } else {
                                block.setWarningText(null);
                                block.setColour("#D4A017");
                            }
                        });

                        // Step 5: Validate 'set_constant_state' and 'get_numeric_constant' dropdowns
                        function validateConstants(retryCount = 0) {
                            let constantBlocks = workspace.getBlocksByType("define_constant", false);
                            let validConstants = constantBlocks
                                .filter(block => {
                                    let value = block.getFieldValue("VALUE")?.trim();
                                    return value && !value.match(/^(?:\d+|(0x|0X)[0-9A-Fa-f]+|(0b|0B)[01]+)$/i);
                                })
                                .map(block => block.getFieldValue("NAME").toUpperCase().trim());
                            let validNumericConstants = constantBlocks
                                .filter(block => {
                                    let value = block.getFieldValue("VALUE")?.trim();
                                    return value && value.match(/^(?:\d+|(0x|0X)[0-9A-Fa-f]+|(0b|0B)[01]+)$/i);
                                })
                                .map(block => block.getFieldValue("NAME").toUpperCase().trim());
                            let allValid = true;

                            // Validate set_constant_state blocks
                            let setConstantStateBlocks = workspace.getBlocksByType("set_constant_state", false);
                            setConstantStateBlocks.forEach(block => {
                                let constantNameField = block.getField("CONSTANT_NAME");
                                let cachedEntry = constantNameCache.find(entry => entry.id === block.id);
                                let cachedName = cachedEntry ? cachedEntry.name : constantNameField.getValue();
                                block.isLoading = false;
                                if (constantNameField && validConstants.includes(cachedName)) {
                                    block.forceSetValue(cachedName);
                                    console.log(`Restored constant ${cachedName} for set_constant_state block`);
                                    block.setWarningText(null);
                                    block.setColour(160);
                                } else {
                                    allValid = false;
                                    block.setWarningText("Error: Referenced constant does not exist or is numeric!", "CONSTANT_MISSING");
                                    block.setColour("#FF0000");
                                    block.forceSetValue(validConstants[0] || "");
                                }
                                constantNameField.setValue(constantNameField.getValue());
                            });

                            // Validate get_numeric_constant blocks
                            let getNumericConstantStateBlocks = workspace.getBlocksByType("get_numeric_constant", false);
                            getNumericConstantStateBlocks.forEach(block => {
                                let constantNameField = block.getField("CONSTANT_NAME");
                                let cachedEntry = numericConstantNameCache.find(entry => entry.id === block.id);
                                let cachedName = cachedEntry ? cachedEntry.name : constantNameField.getValue();
                                block.isLoading = false;
                                if (constantNameField && validNumericConstants.includes(cachedName)) {
                                    block.forceSetValue(cachedName);
                                    console.log(`Restored constant ${cachedName} for get_numeric_constant block`);
                                    block.setWarningText(null);
                                    block.setColour(160);
                                } else {
                                    allValid = false;
                                    block.setWarningText("Error: Selected numeric constant does not exist!", "CONSTANT_MISSING");
                                    block.setColour("#FF0000");
                                    block.forceSetValue(validNumericConstants[0] || "");
                                }
                                constantNameField.setValue(constantNameField.getValue());
                            });

                            if (!allValid && retryCount < 2) {
                                setTimeout(() => validateConstants(retryCount + 1), 500);
                                return;
                            }

                            // Step 6: Initialize code generator and finalize
                            Blockly.JavaScript.init(workspace);
                            workspace.setScale(1.0);
                            workspace.zoomToFit();
                            Blockly.svgResize(workspace);
                            workspace.render();
                            logToWebPageErrors(`XML loaded successfully.\n`, "INFO");
                            if (callback) callback();
                        }

                        workspace.render();
                        setTimeout(() => validateConstants(), 750);
                    } catch (error) {
                        console.error("ERROR: Parsing XML failed!", error);
                        logToWebPageErrors(`Error: Failed to parse XML: ${error.message}\n`, "ERROR");
                    }
                })
                .catch(error => {
                    console.error("ERROR: Failed to load XML:", error);
                    logToWebPageErrors(`Error: Failed to load XML: ${error.message}\n`, "ERROR");
                });
        }

        // revised 1506
        function loadDefaultXML(xmlFile = 'my_blockly_project.xml') {
            // Parse URL parameters to check for optional xml parameter
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.has('xml')) {
                xmlFile = urlParams.get('xml'); // Override with provided XML filename
            }
            console.log(`Loading XML file: ${xmlFile}`);
            loadXml(xmlFile, true, () => {
                console.log("Default XML loaded and workspace initialized.");
            });
        }

        // // revisef 13062025 to hanlde filename
        // // Updated loadDefaultXML function with optional XML filename parameter
        // function loadDefaultXML(xmlFile = 'my_blockly_project.xml') {
        //     // New: Parse URL parameters to check for optional xml parameter
        //     const urlParams = new URLSearchParams(window.location.search);
        //     if (urlParams.has('xml')) {
        //         xmlFile = urlParams.get('xml'); // Override with provided XML filename
                
        //     }
        //     console.log(`${xmlFile}`); // Corrected template literal usage
        //     const fileUrl = new URL(xmlFile, window.location.href).href;
        //     fetch(xmlFile)
        //         .then(response => {
        //             if (!response.ok) {
        //                 throw new Error(`HTTP error! Status: ${response.status}. Ensure ${xmlFile} is next to HTML solution and server allows access.`); // Updated to use dynamic xmlFile
        //             }
        //             return response.text();
        //         })
        //         .then(xmlText => {
        //             try {
        //                 const tempXml = Blockly.utils.xml.textToDom(xmlText);
        //                 const workspace = Blockly.getMainWorkspace();
        //                 workspace.clear();

        //                 let createListBlocks = Array.from(tempXml.getElementsByTagName("block")).filter(block =>
        //                     block.getAttribute("type") === "create_list"
        //                 );

        //                 if (createListBlocks.length === 0) {
        //                     logToWebPageErrors(`No 'create_list' blocks found in ${xmlFile}.\n`, "INFO"); // Updated to use dynamic xmlFile
        //                     Blockly.Xml.domToWorkspace(tempXml, workspace);
        //                 } else {
        //                     // Step 1: Process 'create_list' blocks with XY positions
        //                     createListBlocks.forEach(block => {
        //                         try {
        //                             let x = parseFloat(block.getAttribute("x")) || 50;
        //                             let y = parseFloat(block.getAttribute("y")) || 50;

        //                             const tempXmlDoc = document.createElement('xml');
        //                             const clonedBlock = block.cloneNode(true);
        //                             tempXmlDoc.appendChild(clonedBlock);

        //                             Blockly.Xml.domToWorkspace(tempXmlDoc, workspace);

        //                             const blockId = clonedBlock.getAttribute("id");
        //                             let newBlock = blockId ? workspace.getBlockById(blockId) : workspace.getAllBlocks().find(b => b.type === "create_list" && !b.isInFlyout());
        //                             if (newBlock) {
        //                                 newBlock.moveBy(x, y);
        //                             }

        //                             block.parentNode.removeChild(block);

        //                         } catch (error) {
        //                             // Silently handle errors
        //                         }
        //                     });

        //                     // Step 2: Import remaining blocks from the modified tempXml
        //                     Blockly.Xml.appendDomToWorkspace(tempXml, workspace);

        //                     // Step 3: Validate 'read_table' dropdowns
        //                     let listBlocks = workspace.getBlocksByType("create_list", false);
        //                     let validTables = listBlocks.map(block => block.getFieldValue("LIST_NAME"));
        //                     let tableBlocks = workspace.getBlocksByType("read_table", false);
        //                     tableBlocks.forEach(block => {
        //                         let tableNameField = block.getField("TABLE_NAME");
        //                         if (tableNameField && !validTables.includes(tableNameField.getValue())) {
        //                             block.setWarningText("Error: Referenced table does not exist!", "TABLE_MISSING");
        //                             block.setColour("#FF0000");
        //                             tableNameField.setValue(validTables[0] || "");
        //                         } else {
        //                             block.setWarningText(null);
        //                             block.setColour("#D4A017");
        //                         }
        //                     });
        //                 }

        //                 // Step 4: Reset zoom and fit
        //                 workspace.setScale(1.0);
        //                 workspace.zoomToFit();
        //                 Blockly.svgResize(workspace);
        //                 workspace.resize();
        //                 Blockly.JavaScript.init(workspace);
        //                 logToWebPageErrors(`${xmlFile} loaded and auto-zoomed successfully.\n`, "INFO"); // Updated to use dynamic xmlFile

        //             } catch (e) {
        //                 logToWebPageErrors(`Error loading ${xmlFile}: ${e.message}\n`, "ERROR"); // Updated to use dynamic xmlFile
        //             }
        //         })
        //         .catch(error => {
        //             logToWebPageErrors(`Failed to fetch ${xmlFile}: ${error.message}\n`, "ERROR"); // Updated to use dynamic xmlFile
        //         });
        // }


        ////Added 12062025 to handle create_lists

        //function loadDefaultXML() {
        //    const fileUrl = new URL('my_blockly_project.xml', window.location.href).href;
        //    fetch('my_blockly_project.xml')
        //        .then(response => {
        //            if (!response.ok) {
        //                throw new Error(`HTTP error! Status: ${response.status}. Ensure my_blockly_project.xml is next to HTML solution and server allows access.`);
        //            }
        //            return response.text();
        //        })
        //        .then(xmlText => {
        //            try {
        //                const tempXml = Blockly.utils.xml.textToDom(xmlText);
        //                const workspace = Blockly.getMainWorkspace();
        //                workspace.clear();

        //                let createListBlocks = Array.from(tempXml.getElementsByTagName("block")).filter(block =>
        //                    block.getAttribute("type") === "create_list"
        //                );

        //                if (createListBlocks.length === 0) {
        //                    logToWebPageErrors("No 'create_list' blocks found in my_blockly_project.xml.\n", "INFO");
        //                    Blockly.Xml.domToWorkspace(tempXml, workspace);
        //                } else {
        //                    // Step 1: Process 'create_list' blocks with XY positions
        //                    createListBlocks.forEach(block => {
        //                        try {
        //                            let x = parseFloat(block.getAttribute("x")) || 50;
        //                            let y = parseFloat(block.getAttribute("y")) || 50;

        //                            const tempXmlDoc = document.createElement('xml');
        //                            const clonedBlock = block.cloneNode(true);
        //                            tempXmlDoc.appendChild(clonedBlock);

        //                            Blockly.Xml.domToWorkspace(tempXmlDoc, workspace);

        //                            const blockId = clonedBlock.getAttribute("id");
        //                            let newBlock = blockId ? workspace.getBlockById(blockId) : workspace.getAllBlocks().find(b => b.type === "create_list" && !b.isInFlyout());
        //                            if (newBlock) {
        //                                newBlock.moveBy(x, y);
        //                            }

        //                            block.parentNode.removeChild(block);

        //                        } catch (error) {
        //                            // Silently handle errors
        //                        }
        //                    });

        //                    // Step 2: Import remaining blocks from the modified tempXml
        //                    Blockly.Xml.appendDomToWorkspace(tempXml, workspace);

        //                    // Step 3: Validate 'read_table' dropdowns
        //                    let listBlocks = workspace.getBlocksByType("create_list", false);
        //                    let validTables = listBlocks.map(block => block.getFieldValue("LIST_NAME"));
        //                    let tableBlocks = workspace.getBlocksByType("read_table", false);
        //                    tableBlocks.forEach(block => {
        //                        let tableNameField = block.getField("TABLE_NAME");
        //                        if (tableNameField && !validTables.includes(tableNameField.getValue())) {
        //                            block.setWarningText("Error: Referenced table does not exist!", "TABLE_MISSING");
        //                            block.setColour("#FF0000");
        //                            tableNameField.setValue(validTables[0] || "");
        //                        } else {
        //                            block.setWarningText(null);
        //                            block.setColour("#D4A017");
        //                        }
        //                    });
        //                }

        //                // Step 4: Reset zoom and fit
        //                workspace.setScale(1.0);
        //                workspace.zoomToFit();
        //                Blockly.svgResize(workspace);
        //                workspace.resize();
        //                Blockly.JavaScript.init(workspace);
        //                logToWebPageErrors("my_blockly_project.xml loaded and auto-zoomed successfully.\n", "INFO");

        //            } catch (e) {
        //                logToWebPageErrors(`Error loading my_blockly_project.xml: ${e.message}\n`, "ERROR");
        //            }
        //        })
        //        .catch(error => {
        //            logToWebPageErrors(`Failed to fetch my_blockly_project.xml: ${error.message}\n`, "ERROR");
        //        });
        //}

        //// added 0806
        //function loadDefaultXML() {
        //    const fileUrl = new URL('my_blockly_project.xml', window.location.href).href;
        //    //console.log("Loading XML file from:", fileUrl);
        //    fetch('my_blockly_project.xml')
        //        .then(response => {
        //            if (!response.ok) {
        //                throw new Error(`HTTP error! Status: ${response.status}. Ensure myproject.xml is next to HTML solution and server allows access.`);
        //            }
        //            return response.text();
        //        })
        //        .then(xmlText => {
        //            try {
        //                const xml = Blockly.utils.xml.textToDom(xmlText);
        //                Blockly.Xml.domToWorkspace(xml, workspace);
        //                logToWebPageErrors("my_blockly_project.xml loaded successfully.\n");
        //                // Auto-zoom to fit all blocks after a short delay
        //                setTimeout(() => {
        //                    workspace.zoomToFit();
        //                    logToWebPageErrors("Workspace auto-zoomed to fit blocks.", "INFO");
        //                    Blockly.svgResize(workspace);
        //                    workspace.resize();
        //                }, 200); // Delay to ensure blocks are rendered
        //            } catch (e) {
        //                logToWebPageErrors(`Error loading my_blockly_project.xml: ${e.message}\n`, "ERROR");
        //            }
        //        })
        //        .catch(error => {
        //            logToWebPageErrors(`Failed to fetch my_blockly_project.xml: ${error.message}\n`, "ERROR");
        //        });
        //}

        function makeDraggable(element) {
            let isDragging = false;
            let currentX, currentY, initialX, initialY;
            let zIndex = 1;
            const blocklyDiv = document.getElementById('blocklyDiv');
            const blocklyRect = blocklyDiv ? blocklyDiv.getBoundingClientRect() : { bottom: 0, height: 0 };
            const isError = element.querySelector('#WebPageErrors-header') !== null;
            const windowHeight = window.innerHeight;
            const marginFromBottom = 0; // Margin from the bottom of the viewport

            // Calculate initial Y position based on blocklyDiv bottom, adjusted for 80vh height
            const blocklyHeight = blocklyRect.height || (0.8 * windowHeight); // Fallback to 80% of viewport if not rendered
            currentY = blocklyRect.bottom + 10; // 10px below blocklyDiv bottom
            //if (currentY + 100 > windowHeight - marginFromBottom) { // Ensure within viewport with console height (~100px)
            //    currentY = windowHeight + marginFromBottom; // Position above bottom margin
            //}

            if (isError) {
                currentX = 100; // System Log on the left
            } else {
                currentX = 540; // GCBASIC Output offset
            }
            element.style.position = 'absolute';
            element.style.left = `${currentX}px`;
            element.style.top = `${currentY}px`;

            element.addEventListener('mousedown', (e) => {
                if (e.target.tagName === 'H3') {
                    initialX = e.clientX - currentX;
                    initialY = e.clientY - currentY;
                    isDragging = true;
                    element.style.zIndex = ++zIndex;
                }
            });

            element.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    e.preventDefault();
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;
                    element.style.left = `${currentX}px`;
                    element.style.top = `${currentY}px`;
                    try {
                        saveLayoutState(); // Save state during drag
                    }
                    catch (e) {
                    }
                }
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
        }

        //function makeDraggable(element) {
        //    let isDragging = false;
        //    let currentX, currentY, initialX, initialY;
        //    let zIndex = 1;
        //    const blocklyDiv = document.getElementById('blocklyDiv');
        //    const blocklyRect = blocklyDiv.getBoundingClientRect();
        //    const isError = element.querySelector('#WebPageErrors-header') !== null;
        //    currentY = blocklyRect.bottom + 40;
        //    currentX = isError ? 10 : 440;
        //    element.style.position = 'absolute';
        //    element.style.left = `${currentX}px`;
        //    element.style.top = `${currentY}px`;
        //    element.addEventListener('mousedown', (e) => {
        //        if (e.target.tagName === 'H3') {
        //            initialX = e.clientX - currentX;
        //            initialY = e.clientY - currentY;
        //            isDragging = true;
        //            element.style.zIndex = ++zIndex;
        //        }
        //    });
        //    document.addEventListener('mousemove', (e) => {
        //        if (isDragging) {
        //            e.preventDefault();
        //            currentX = e.clientX - initialX;
        //            currentY = e.clientY - initialY;
        //            element.style.left = `${currentX}px`;
        //            element.style.top = `${currentY}px`;
        //        }
        //    });
        //    document.addEventListener('mouseup', () => {
        //        isDragging = false;
        //    });
        //}

        function newProject() {
            Blockly.getMainWorkspace().clear();
            // Call the background image function
            addBackgroundImage("GCstudio.png", 10000); // Default image and 10-second duration
        }

        function openProject() {
            var fileInput = document.getElementById("fileInput");
            if (!fileInput) {
                logToWebPageErrors("Error: File input element not found!\n", "ERROR");
                return;
            }
            fileInput.value = ""; // Reset file input
            fileInput.onchange = function (event) {
                var file = event.target.files[0];
                if (!file) {
                    logToWebPageErrors("Error: No file selected!\n", "ERROR");
                    return;
                }
                loadXml(file, true, () => {
                    logToWebPageErrors("Project file opened successfully!\n", "INFO");
                    addBackgroundImage("GCstudio.png", 10000); // Add background image after loading
                });
            };
            fileInput.click();
        }

        // function openProject() {
        //     var fileInput = document.getElementById("fileInput");
        //     if (!fileInput) {
        //         console.error("Error: fileInput element is missing!");
        //     } else {
        //         fileInput.click();
        //         // Call the background image function
        //         addBackgroundImage("GCstudio.png", 10000); // Default image and 10-second duration
        //     }
        // }

        function populateChipDropdown() {
            const select = document.getElementById('chipSelect');
            chipData.forEach(chip => {
                let option = document.createElement('option');
                option.value = chip.name;
                option.textContent = `${chip.name} (${chip.clock} MHz)`;
                select.appendChild(option);
            });
        }

        function reformatCode(code, indentLevel) {
            var lines = code.split('\n').filter(line => line.trim());
            if (!lines.length) return tab(indentLevel) + '\' No code provided';
            var minIndent = Math.min(...lines
                .filter(line => line.trim())
                .map(line => line.match(/^\s*/)[0].length / 4));
            return lines
                .map(line => {
                    if (!line.trim()) return '';
                    var lineIndent = (line.match(/^\s*/)[0].length / 4) - minIndent;
                    return tab(indentLevel + lineIndent) + line.trim();
                })
                .filter(line => line)
                .join('\n');
        }

        function resetWorkspace() {
            if (confirm("Are you sure you want to clear all blocks?")) {
                Blockly.getMainWorkspace().clear();
                // Call the background image function
                addBackgroundImage("GCstudio.png", 10000); // Default image and 10-second duration
                localStorage.setItem("username", "");
            }
        }


        // Persistent Usage Counter with XML Logging
        const XML_FILE = "visit_log.xml";

        // Function to load XML visits
        const loadXMLVisits = () => {
            return new Promise((resolve) => {
                fetch(XML_FILE)
                    .then(response => response.text())
                    .then(xmlText => {
                        const parser = new DOMParser();
                        const xmlDoc = parser.parseFromString(xmlText, "application/xml");
                        const visits = Array.from(xmlDoc.getElementsByTagName("visit")).map(visit => ({
                            ip: visit.getElementsByTagName("ip")[0].textContent,
                            url: visit.getElementsByTagName("url")[0].textContent
                        }));
                        resolve(visits);
                    })
                    .catch(() => resolve([])); // If XML file does not exist yet
            });
        };

        // Function to update XML log
        const updateXMLLog = (ip, url) => {
            loadXMLVisits().then(visits => {
                if (visits.some(v => v.ip === ip && v.url === url)) return; // Prevent duplicate logging

                const xmlContent = `
            <visits>
                ${visits.map(v => `<visit><ip>${v.ip}</ip><url>${v.url}</url></visit>`).join('')}
                <visit><ip>${ip}</ip><url>${url}</url></visit>
            </visits>
        `;

                // Send updated XML data to server-side handler (e.g., PHP/Python API)
                fetch("update_visit_log.php", {
                    method: "POST",
                    headers: { "Content-Type": "application/xml" },
                    body: xmlContent
                });
            });
        };

        const generateVisitorId = () => {
            const fingerprint = [
                navigator.userAgent,
                navigator.language,
                screen.width + 'x' + screen.height,
                screen.colorDepth,
                new Date().getTimezoneOffset()
            ].join('|');

            let hash = 0;
            for (let i = 0; i < fingerprint.length; i++) {
                const char = fingerprint.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return Math.abs(hash).toString(36);
        };

        const trackPageUsage = async () => {
            const currentUrl = window.location.href;
            const visitorId = generateVisitorId(); // Using fingerprinting logic from your original code

            // Get client IP address
            const response = await fetch("https://api64.ipify.org?format=json");
            const data = await response.json();
            const clientIp = data.ip;

            // Fetch XML visit log and update hit count
            fetch("https://gcbasic.com/visit_log.xml")
                .then(response => response.text())
                .then(xmlText => {
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlText, "application/xml");
                    let visits = Array.from(xmlDoc.getElementsByTagName("visit")).map(visit => ({
                        ip: visit.getElementsByTagName("ip")[0].textContent,
                        url: visit.getElementsByTagName("url")[0].textContent,
                        hits: visit.getElementsByTagName("hits")[0] ? parseInt(visit.getElementsByTagName("hits")[0].textContent) : 1
                    }));

                    // Update or add visitor
                    let found = false;
                    visits = visits.map(v => {
                        if (v.ip === clientIp && v.url === currentUrl) {
                            found = true;
                            return { ...v, hits: v.hits + 1 };
                        }
                        return v;
                    });

                    if (!found) {
                        visits.push({ ip: clientIp, url: currentUrl, hits: 1 });
                    }

                    // Generate updated XML content
                    const xmlContent = `
                <visits>
                    ${visits.map(v => `<visit><ip>${v.ip}</ip><url>${v.url}</url><hits>${v.hits}</hits></visit>`).join('')}
                </visits>
            `;

                    // Send updated XML data to server-side handler
                    fetch("https://gcbasic.com/update_visit_log.php", {
                        method: "POST",
                        headers: { "Content-Type": "application/xml" },
                        body: xmlContent
                    });

                    // Log total unique visitors
                    const uniqueIps = new Set(visits.map(v => v.ip));
                    //console.log(`=== PERSISTENT USAGE STATISTICS ===`);
                    //console.log(`Total unique visitors: ${uniqueIps.size}`);
                    //console.log(`Unique IPs with hit counts:`, visits);
                    //console.log(`==================================`);
                    console.log(`.. ${uniqueIps.size}`);
                })
                .catch(() => {
                    console.log("Failed to load XML file or update visitor log.");
                });
        };


        function runCode() {
            if (!workspace) {
                logToWebPageErrors("Error: Blockly workspace is not initialized!\n", "ERROR");
                return;
            }
            clearConsole();
            Blockly.JavaScript.init(workspace);
            const today = new Date();
            const formattedDate = `${String(today.getMonth() + 1).padStart(2, '0')}/${String(today.getDate()).padStart(2, '0')}/${today.getFullYear()}`;
            var localuname = localStorage.getItem("username") || "";
            if (localuname.trim() === "") {
                localuname = prompt("Enter your username:");
                localStorage.setItem("username", localuname);
            }
            let chipCode = '';
            let code = '';
            if (!Blockly.JavaScript.workspaceToCode(workspace).trim()) {
                logToWebPageErrors("Error: No blocks in the workspace!\n", "WARNING");
                return;
            }
            Blockly.JavaScript.init(workspace);
            let chipProcessed = false;
            const topBlocks = workspace.getTopBlocks(true);
            for (let i = 0; i < topBlocks.length; i++) {
                let block = topBlocks[i];
                while (block && block.isEnabled()) {
                    try {
                        if (block.type === 'select_chip') {
                            chipCode = Blockly.JavaScript.forBlock['select_chip'](block);
                            chipProcessed = true;
                        }
                    } catch (e) {
                        console.error(`DEBUG: Error in block ${block.type}: ${e.message}`);
                        code += `// Error in block ${block.type}: ${e.message}\n`;
                    }
                    block = block.getNextBlock();
                }
                if (chipProcessed) {
                    break;
                }
            }
            if (!chipProcessed) {
                console.error(`No chip specified`);
                logToWebPageErrors("Error: No chip specified\n", "ERROR");
                console.log("No Generated Code:\n");
                return;
            }
            code = `/*
            GCBASIC source generated by BLOCKLY.  An Open source code generator.

           A GCBASIC source program

*/
// Date:    ${formattedDate}
// Version: 0.9b
// Author:  ${localuname}
\n`;
            code += chipCode;
            var constantscode = "";
            for (let i = 0; i < topBlocks.length; i++) {
                let block = topBlocks[i];
                function extractConstants(innerBlock) {
                    let currentBlock = innerBlock;
                    while (currentBlock) {
                        try {
                            if (currentBlock.isEnabled()) {
                                if (currentBlock.type === 'define_constant') {
                                    constantscode += Blockly.JavaScript.forBlock['define_constant'](currentBlock);
                                } else if (currentBlock.type === 'constant_block_group') {
                                    let childBlocks = currentBlock.getChildren ? currentBlock.getChildren() : [];
                                    for (let j = 0; j < childBlocks.length; j++) {
                                        extractConstants(childBlocks[j]);
                                    }
                                }
                            }
                        } catch (e) {
                            console.error(`DEBUG: Error in block ${currentBlock.type}: ${e.message}`);
                        }
                        currentBlock = currentBlock.getNextBlock();
                    }
                }
                extractConstants(block);
            }
            if (constantscode.trim() !== "") {
                code += '// Constants used\n';
                code += constantscode;
                code += "\n"
            }

            var variablescode = "";
            for (let i = 0; i < topBlocks.length; i++) {
                let block = topBlocks[i];
                function extractVariables(innerBlock) {
                    let currentBlock = innerBlock;
                    while (currentBlock) {
                        try {
                            if (currentBlock.isEnabled()) {
                                if (currentBlock.type === 'numeric_variable') {
                                    variablescode += Blockly.JavaScript.forBlock['numeric_variable'](currentBlock);
                                } else if (currentBlock.type === 'variable_block_group') {
                                    let childBlocks = currentBlock.getChildren ? currentBlock.getChildren() : [];
                                    for (let j = 0; j < childBlocks.length; j++) {
                                        extractVariables(childBlocks[j]);
                                    }
                                }
                            }
                        } catch (e) {
                            console.error(`DEBUG: Error in block ${currentBlock.type}: ${e.message}`);
                        }
                        currentBlock = currentBlock.getNextBlock();
                    }
                }
                extractVariables(block);
            }
            if (variablescode.trim() !== "") {
                code += '// Global Numeric Variables used\n';
                code += variablescode;
                code += "\n"
            }

            var stringscode = "";
            for (let i = 0; i < topBlocks.length; i++) {
                let block = topBlocks[i];
                function extractVariables(innerBlock) {
                    while (innerBlock && innerBlock.isEnabled()) {
                        try {
                            if (innerBlock.type === 'string_variable') {
                                stringscode += Blockly.JavaScript.forBlock['string_variable'](innerBlock);
                            } else if (innerBlock.type === 'variable_block_group') {
                                let childBlocks = innerBlock.getChildren ? innerBlock.getChildren() : [];
                                for (let j = 0; j < childBlocks.length; j++) {
                                    extractVariables(childBlocks[j]);
                                }
                            }
                        } catch (e) {
                            console.error(`DEBUG: Error in block ${innerBlock.type}: ${e.message}`);
                        }
                        innerBlock = innerBlock.getNextBlock();
                    }
                }
                extractVariables(block);
            }
            if (stringscode.trim() !== "") {
                code += '// Global String Variables used\n';
                code += stringscode;
                code += "\n"
            }
            code += '\n// Main Program Commences Here \n\n';
            for (let i = 0; i < topBlocks.length; i++) {
                let block = topBlocks[i];
                while (block && block.isEnabled()) {
                    try {

                        if (!excludedBlockTypes.includes(block.type) && Blockly.JavaScript.forBlock[block.type]) {
                            const blockCode = Blockly.JavaScript.forBlock[block.type](block);
                            code += blockCode;
                        }
    
                    } catch (e) {
                        console.error(`DEBUG: Error in block ${block.type}: ${e.message}`);
                        code += `// Error in block ${block.type}: ${e.message}\n`;
                    }
                    block = block.getNextBlock();
                }
            }


            var subroutinecode = "";
            for (let i = 0; i < topBlocks.length; i++) {
                let block = topBlocks[i];
                function extractConstants(innerBlock) {
                    while (innerBlock && innerBlock.isEnabled()) {
                        try {
                            if (innerBlock.type === 'user_subroutine') {
                                subroutinecode += Blockly.JavaScript.forBlock['user_subroutine'](innerBlock);
                            } else if (innerBlock.type === 'user_subroutine_block_group') {
                                let childBlocks = innerBlock.getChildren ? innerBlock.getChildren() : [];
                                for (let j = 0; j < childBlocks.length; j++) {
                                    extractConstants(childBlocks[j]);
                                }
                            }
                        } catch (e) {
                            console.error(`DEBUG: Error in block ${innerBlock.type}: ${e.message}`);
                        }
                        innerBlock = innerBlock.getNextBlock();
                    }
                }
                extractConstants(block);
            }
            if (subroutinecode.trim() !== "") {
                code += '\n\n// Sub Routines defined';
                code += subroutinecode;
                code += "\n"
            }

            var tablecode = "";
            for (let i = 0; i < topBlocks.length; i++) {
                let block = topBlocks[i];
                function extractTables(innerBlock) {
                    while (innerBlock && innerBlock.isEnabled()) {
                        try {
                            if (innerBlock.type === 'create_list') {
                                tablecode += Blockly.JavaScript.forBlock['create_list'](innerBlock);
                            }
                            else if (innerBlock.type === 'create_list_block_group') {
                                let childBlocks = innerBlock.getChildren ? innerBlock.getChildren() : [];
                                for (let j = 0; j < childBlocks.length; j++) {
                                    extractTables(childBlocks[j]);
                                }
                            }
                        } catch (e) {
                            console.error(`DEBUG: Error in block ${innerBlock.type}: ${e.message}`);
                        }
                        innerBlock = innerBlock.getNextBlock();
                    }
                }
                extractTables(block);
            }
            if (tablecode.trim() !== "") {
                code += '\n\n//Tables defined\n';
                code += tablecode;
                code += "\n"
            }



            var numberedCode = code.split('\n').map((line, i) => `${i + 1}: ${line}`).join('\n');
            logToWebpageConsole(code);
        }


        function saveProject() {
            let filename = prompt("Enter filename:", "my_blockly_project.xml");
            if (!filename) {
                console.log("Save operation canceled.");
                return;
            }
            const savedFiles = JSON.parse(localStorage.getItem("savedFiles") || "[]");
            if (savedFiles.includes(filename)) {
                const confirmOverwrite = confirm(`"${filename}" already exists. Do you want to overwrite it?`);
                if (!confirmOverwrite) {
                    console.log("User canceled overwrite.");
                    return;
                }
            }
            var xml = Blockly.Xml.workspaceToDom(Blockly.getMainWorkspace());
            var xmlText = Blockly.Xml.domToText(xml);
            var blob = new Blob([xmlText], { type: "text/xml" });
            var a = document.createElement("a");
            a.href = URL.createObjectURL(blob);
            a.download = filename;
            a.click();
            savedFiles.push(filename);
            localStorage.setItem("savedFiles", JSON.stringify(savedFiles));
            console.log(`File "${filename}" saved successfully.`);
        }

        async function saveProjectOS() {
            const options = {
                suggestedName: "my_blockly_project.xml",
                types: [{ description: "XML Files", accept: { "text/xml": [".xml"] } }]
            };
            const handle = await window.showSaveFilePicker(options);
            const writable = await handle.createWritable();
            await writable.write("Your file content here");
            await writable.close();
            console.log("File saved!");
        }

        function sanitizeCondition(condition) {
            if (!condition || condition.trim() === '') {
                logToWebPageErrors('Empty condition, defaulting to "true"', "WARNING");
                return 'true';
            }
            const validGCBBASICPattern = /^[a-zA-Z0-9_\s]+(\s*(=|<>|<|>|<=|>=)\s*[a-zA-Z0-9_\s]+)*$/;
            if (!validGCBBASICPattern.test(condition)) {
                logToWebPageErrors(`Invalid GCBBASIC condition: "${condition}", defaulting to "true"`, "ERROR");
                return 'true';
            }
            return condition;
        }

        function sanitizeRepeatCount(count) {
            var num = Math.floor(Number(count));
            if (isNaN(num) || num < 0) {
                logToWebPageErrors(`Invalid repeat count "${count}", defaulting to 0`, "WARNING");
                return 0;
            }
            if (num > 65535) {
                logToWebPageErrors(`Repeat count "${count}" exceeds maximum 65535, capping at 65535\n`, "WARNING");
                return 65535;
            }
            return num;
        }

        function tab(indentLevel) {
            return '    '.repeat(indentLevel || indentationStack[indentationStack.length - 1] || 0);
        }

        function tightCleanup(workspace) {
            workspace.cleanUp();
            let blocks = workspace.getTopBlocks(true);
            let yPosition = 5;
            let xPosition = 5;
            let yOverset = 5;
            blocks.forEach(block => {
                const blockHeight = block.getHeightWidth().height;
                block.xy_ = { x: xPosition, y: yPosition };
                block.moveTo(block.xy_);
                yPosition += blockHeight + yOverset;
            });
            workspace.render();
            console.log("Precise Cleanup applied with Y overset:", yOverset);
        }

            function toggleGrid() {
                gridVisible = !gridVisible;
                const button = document.getElementById('toggleGridButton');
                button.textContent = `Toggle Grid (${gridVisible ? 'On' : 'Off'})`;

                // Toggle grid visibility and snapping
                const gridPattern = workspace.getParentSvg().querySelector('pattern');
                if (gridPattern) {
                    gridPattern.style.display = gridVisible ? 'block' : 'none';
                }

                // Update snapping behavior
                if (workspace.options && workspace.options.grid) {
                workspace.options.grid.snap = gridVisible;
                }
                if (workspace.grid_) {
                workspace.grid_.snapToGrid_ = gridVisible;
                }


                // Log the change
                logToWebPageErrors(`Grid toggled ${gridVisible ? 'on' : 'off'}.\n`, "INFO");

                // Ensure workspace rendering is updated
                Blockly.svgResize(workspace);
                workspace.resize();
            }

        // function toggleGrid() {
        //     gridVisible = !gridVisible;
        //     const button = document.getElementById('toggleGridButton');
        //     button.textContent = `Toggle Grid (${gridVisible ? 'On' : 'Off'})`;

        //     // Save workspace state as XML
        //     const xmlDom = Blockly.Xml.workspaceToDom(workspace);
        //     const xmlText = Blockly.Xml.domToText(xmlDom);
        //     logToWebPageErrors(`Saved XML state\n`, "INFO"); // Debug log

        //     // Reinitialize workspace with updated grid settings
        //     const blocklyDiv = document.getElementById('blocklyDiv');
        //     const originalScroll = blocklyDiv.scrollTop; // Save scroll position
        //     const originalWidth = blocklyDiv.style.width;
        //     const originalHeight = blocklyDiv.style.height;
        //     blocklyDiv.innerHTML = ''; // Clear the div
        //     workspace.dispose(); // Dispose of the current workspace

        //     // Re-inject workspace with new grid settings
        //     workspace = Blockly.inject('blocklyDiv', {
        //         toolbox: document.getElementById('toolbox'),
        //         grid: {
        //             spacing: 10,
        //             length: gridVisible ? 2 : 0, // Toggle grid length between 2 (visible) and 0 (hidden)
        //             colour: '#ccc',
        //             snap: true
        //         },
        //         zoom: {
        //             controls: true,
        //             wheel: true,
        //             startScale: 1.0,
        //             maxScale: 3,
        //             minScale: 0.3,
        //             scaleSpeed: 1.2
        //         },
        //         move: {
        //             scrollbars: true,
        //             drag: true
        //         }
        //     });
        //     logToWebPageErrors("Workspace reinitialized.\n", "INFO"); // Debug log

        //     // Restore workspace state from XML after ensuring workspace is ready
        //     setTimeout(() => {
        //         try {
        //             const restoredXml = Blockly.utils.xml.textToDom(xmlText); // Correct method
        //             Blockly.Xml.domToWorkspace(restoredXml, workspace); // Load XML into workspace
        //             logToWebPageErrors("XML restored to workspace."); // Debug log
        //         } catch (error) {
        //             logToWebPageErrors(`Error restoring XML: ${error.message}\n`, "ERROR");
        //             console.error("XML Restoration Error:", error, "XML:", xmlText);
        //             return; // Stop execution if restoration fails
        //         }
        //         // Restore scroll position and dimensions
        //         blocklyDiv.scrollTop = originalScroll;
        //         blocklyDiv.style.width = originalWidth;
        //         blocklyDiv.style.height = originalHeight;
        //         document.getElementById('runButton').disabled = false;
        //         //setTimeout(() => {
        //         //    Blockly.svgResize(workspace);
        //         //    workspace.resize();
        //         //    logToWebPageErrors("Workspace resized.\n","INFO"); // Debug log
        //         //}, 100);
        //     }, 200); // Delay to ensure workspace is ready
        // }

        // // Override the scrub_ function that handles comments
        // Blockly.JavaScript.scrub_ = function (block, code) {
        //     var nextBlock = block.nextConnection && block.nextConnection.targetBlock();
        //     var nextCode = Blockly.JavaScript.blockToCode(nextBlock);
        //     return code + nextCode; // Remove comment insertion here
        // }


        function handleFileSelect(event) {
            var file = event.target.files[0];
            if (!file) {
                return;
            }

            var reader = new FileReader();
            reader.onload = function () {
                try {
                    var tempXml = Blockly.utils.xml.textToDom(reader.result);
                    var workspace = Blockly.getMainWorkspace();
                    workspace.clear();

                    let createListBlocks = Array.from(tempXml.getElementsByTagName("block")).filter(block =>
                        block.getAttribute("type") === "create_list"
                    );

                    if (createListBlocks.length === 0) {
                        return;
                    }

                    // Step 1: Process 'create_list' blocks with XY positions
                    createListBlocks.forEach(block => {
                        try {
                            let x = parseFloat(block.getAttribute("x")) || 50;
                            let y = parseFloat(block.getAttribute("y")) || 50;

                            const tempXmlDoc = document.createElement('xml');
                            const clonedBlock = block.cloneNode(true);
                            tempXmlDoc.appendChild(clonedBlock);

                            Blockly.Xml.domToWorkspace(tempXmlDoc, workspace);

                            const blockId = clonedBlock.getAttribute("id");
                            let newBlock = blockId ? workspace.getBlockById(blockId) : workspace.getAllBlocks().find(b => b.type === "create_list" && !b.isInFlyout());
                            if (newBlock) {
                                newBlock.moveBy(x, y); // Apply position immediately
                            }

                            block.parentNode.removeChild(block);

                        } catch (error) {
                            // Silently handle errors
                        }
                    });

                    // Step 2: Import remaining blocks from the modified tempXml
                    Blockly.Xml.appendDomToWorkspace(tempXml, workspace);

                    // Step 3: Validate 'read_table' dropdowns
                    let listBlocks = workspace.getBlocksByType("create_list", false);
                    let validTables = listBlocks.map(block => block.getFieldValue("LIST_NAME"));
                    let tableBlocks = workspace.getBlocksByType("read_table", false);
                    tableBlocks.forEach(block => {
                        let tableNameField = block.getField("TABLE_NAME");
                        if (tableNameField && !validTables.includes(tableNameField.getValue())) {
                            block.setWarningText("Error: Referenced table does not exist!", "TABLE_MISSING");
                            block.setColour("#FF0000");
                            tableNameField.setValue(validTables[0] || "");
                        } else {
                            block.setWarningText(null);
                            block.setColour("#D4A017");
                        }
                    });

                    // Step 4: Reset zoom and fit, then remove bounding box if present
                    workspace.setScale(1.0);
                    workspace.zoomToFit();
                    Blockly.svgResize(workspace);
                    workspace.resize();
                    Blockly.JavaScript.init(workspace);

                    // Remove bounding box if it exists
                    const svg = workspace.getInjectionDiv().querySelector('svg.blocklySvg');
                    const bbox = svg ? svg.querySelector('rect') : null;
                    if (bbox) {
                        bbox.remove();
                    }

                } catch (error) {
                    // Silently handle errors
                }
            };

            reader.readAsText(file);
        }

        //function handleFileSelect(event) {
        //    var file = event.target.files[0];
        //    if (!file) {
        //        console.error("ERROR: No file selected!");
        //        return;
        //    }

        //    var reader = new FileReader();
        //    reader.onload = function () {
        //        try {
        //            console.clear();
        //            console.log("DEBUG: Starting import process...");

        //            var tempXml = Blockly.utils.xml.textToDom(reader.result);
        //            var workspace = Blockly.getMainWorkspace();
        //            workspace.clear();

        //            console.log("DEBUG: Extracting 'create_list' blocks...");
        //            let createListBlocks = Array.from(tempXml.getElementsByTagName("block")).filter(block =>
        //                block.getAttribute("type") === "create_list"
        //            );

        //            if (createListBlocks.length === 0) {
        //                console.error("ERROR: No 'create_list' blocks found in XML! Aborting.");
        //                return;
        //            }

        //            console.log(`DEBUG: Found ${createListBlocks.length} 'create_list' blocks. Validating XML format...`);
        //            console.log("DEBUG: Raw XML structure:", new XMLSerializer().serializeToString(tempXml));

        //            // Step 1: Preserve X, Y coordinates before inserting blocks
        //            createListBlocks.forEach(block => {
        //                try {
        //                    console.log("DEBUG: Attempting to add 'create_list' block:", block);

        //                    // Extract X, Y coordinates from block
        //                    let x = block.getAttribute("x") || 50; // Default position if missing
        //                    let y = block.getAttribute("y") || 50;

        //                    // Create a temporary XML document with the cloned block
        //                    const tempXml = document.createElement('xml');
        //                    const clonedBlock = block.cloneNode(true);
        //                    tempXml.appendChild(clonedBlock);

        //                    // Convert to workspace
        //                    let newBlock = Blockly.Xml.domToWorkspace(tempXml, workspace);

        //                    // Apply stored X, Y positions to the newly added block
        //                    if (newBlock) {
        //                        newBlock.moveBy(parseFloat(x), parseFloat(y));
        //                        console.log(`DEBUG: Positioned 'create_list' block at (${x}, ${y}).`);
        //                    }

        //                } catch (error) {
        //                    console.error(`ERROR: Failed to add 'create_list' block!`, error);
        //                }
        //            });

        //            console.log("DEBUG: Forced 'create_list' block addition. Waiting for workspace to reflect changes...");

        //            setTimeout(() => {
        //                let listBlocks = workspace.getBlocksByType("create_list", false);
        //                console.log(`DEBUG: Workspace now contains ${listBlocks.length} 'create_list' blocks.`);

        //                if (listBlocks.length === 0) {
        //                    console.error("ERROR: 'create_list' blocks were still not added. Inspecting Blockly workspace...");
        //                    console.log("DEBUG: Current workspace state:", Blockly.Xml.workspaceToDom(workspace));
        //                    return;
        //                }

        //                console.log("DEBUG: 'create_list' blocks confirmed in workspace. Proceeding with remaining XML import...");

        //                // Step 2: Append remaining blocks separately (avoiding duplicate 'create_list' imports)
        //                Blockly.Xml.appendDomToWorkspace(tempXml, workspace);
        //                console.log("DEBUG: Remaining blocks imported successfully!");

        //                // Step 3: Validate 'read_table' dropdowns
        //                let validTables = listBlocks.map(block => block.getFieldValue("LIST_NAME"));
        //                let tableBlocks = workspace.getBlocksByType("read_table", false);
        //                tableBlocks.forEach(block => {
        //                    let tableNameField = block.getField("TABLE_NAME");

        //                    if (tableNameField && !validTables.includes(tableNameField.getValue())) {
        //                        block.setWarningText("Error: Referenced table does not exist!", "TABLE_MISSING");
        //                        block.setColour("#FF0000");
        //                        tableNameField.setValue(validTables[0] || "");
        //                        console.log(`DEBUG: Updated dropdown in 'read_table' block to valid table: ${validTables[0] || "None Found"}`);
        //                    } else {
        //                        block.setWarningText(null);
        //                        block.setColour("#D4A017");
        //                    }
        //                });

        //                console.log("DEBUG: Ensured 'read_table' dropdown references valid tables.");

        //                // Step 4: Delay Blockly CodeGenerator initialization until all blocks are fully restored
        //                setTimeout(() => {
        //                    Blockly.JavaScript.init(workspace);
        //                    console.log("DEBUG: Code generator initialized successfully!");
        //                }, 150);

        //            }, 500);

        //        } catch (error) {
        //            console.error("ERROR: Parsing XML failed!", error);
        //            console.error("DEBUG: Received XML content:", reader.result);
        //        }
        //    };

        //    reader.readAsText(file);
        //}

        // worked before 12062025
        //function handleFileSelect(event) {
        //    var file = event.target.files[0];
        //    if (!file) {
        //        console.error("No file selected!");
        //        return;
        //    }
        //    var reader = new FileReader();
        //    reader.onload = function () {
        //        try {
        //            var xml = Blockly.utils.xml.textToDom(reader.result);
        //            Blockly.Xml.clearWorkspaceAndLoadFromXml(xml, workspace); // Clear and load with comments
        //            console.log("Blocks and comments imported successfully!");
        //        } catch (error) {
        //            console.error("Error parsing XML:", error);
        //            console.error("Received XML:", reader.result);
        //            logToWebPageErrors(`Error loading file: ${error.message}\n`, "ERROR");
        //        }
        //    };
        //    reader.readAsText(file);
        //}

        //function xhandleFileSelect(event) {
        //    var file = event.target.files[0];
        //    var reader = new FileReader();
        //    reader.onload = function () {
        //        var xml = Blockly.utils.xml.textToDom(reader.result);
        //        Blockly.Xml.clearWorkspaceAndLoadFromXml(xml, Blockly.getMainWorkspace());
        //    };
        //    reader.readAsText(file);
        //}


        // Remove this function entirely
        // function populateChipDropdown() { ... }

        window.onload = () => {
            //console.log("Initializing Blockly workspace...");
            try {
                workspace = Blockly.inject('blocklyDiv', {
                    toolbox: document.getElementById('toolbox'),
                    comments: true,
                    grid: {
                        spacing: 10,
                        length: 2,
                        colour: '#ccc',
                        snap: true
                    },
                    zoom: {
                        controls: true,
                        wheel: true,
                        startScale: 1.0,
                        maxScale: 3,
                        minScale: 0.3,
                        scaleSpeed: 1.2
                    },
                    move: {
                        scrollbars: true,
                        drag: true,
                        comments: true
                    }
                });
                document.getElementById('runButton').disabled = false;
                document.getElementById('toggleGridButton').textContent = 'Toggle Grid (On)';

                toggleGrid();

                // Call the background image function
                addBackgroundImage("GCstudio.png", 10000); // Default image and 10-second duration

                setTimeout(() => {
                    const blocklyDiv = document.getElementById('blocklyDiv');
                    const gridSize = 10;
                    new ResizeObserver(() => {
                        const width = blocklyDiv.offsetWidth;
                        const height = blocklyDiv.offsetHeight;
                        const snappedWidth = Math.round(width / gridSize) * gridSize;
                        const snappedHeight = Math.round(height / gridSize) * gridSize;
                        blocklyDiv.style.width = `${snappedWidth}px`;
                        blocklyDiv.style.height = `${snappedHeight}px`;
                        Blockly.svgResize(workspace);
                    }).observe(blocklyDiv);
                    Blockly.svgResize(workspace);
                    workspace.resize();
                }, 100);

                loadDefaultXML();

                // Trigger tracking
                const isLocalhost = window.location.origin.includes("localhost") || window.location.origin.includes("127.0.0.1");
                if (!isLocalhost) {
                    // trackPageUsage();
                }

            } catch (error) {
                console.error("Error initializing Blockly:", error);
                logToWebPageErrors(`Error: Blockly initialization failed: ${error.message}\n`, "ERROR");
            }
            if (workspace) {
                workspace.addChangeListener(event => {
                    if (event.type === Blockly.Events.BLOCK_CREATE) {
                        var block = workspace.getBlockById(event.blockId);
                        if (block && (block.type === 'get_variable' || block.type === 'set_variable')) {
                            var varName = block.getField('VAR_NAME').getVariable().name;
                            var exists = workspace.getAllBlocks().some(b =>
                                b.type === 'numeric_variable' && b.getFieldValue("VAR_NAME") === varName
                            );
                            if (!exists) {
                                var newBlock = workspace.newBlock('numeric_variable');
                                newBlock.setFieldValue(varName, "VAR_NAME");
                                newBlock.initSvg();
                                newBlock.render();
                                newBlock.moveBy(100, 100);
                            }
                        }
                    }
                });
                workspace.addChangeListener(function (event) {
                    var affectedBlock = workspace.getBlockById(event.blockId);
                    if (affectedBlock) {
                        var parentBlock = affectedBlock.getSurroundParent();
                        if (parentBlock && parentBlock.type === 'constant_block_group') {
                            let ejectedBlocks = [];
                            let invalidBlock = null;
                            let childBlock = parentBlock.getInputTargetBlock('INNER_BLOCKS');
                            while (childBlock) {
                                if (childBlock.type === "define_constant") {
                                    ejectedBlocks.push(childBlock);
                                } else {
                                    invalidBlock = childBlock;
                                }
                                childBlock = childBlock.getNextBlock() ? childBlock.getNextBlock() : null;
                            }
                            if (ejectedBlocks.length > 0) {
                                let firstBlock = ejectedBlocks[0];
                                parentBlock.getInputTargetBlock('INNER_BLOCKS').nextConnection.connect(firstBlock.previousConnection);
                                let previousBlock = firstBlock;
                                for (let i = 1; i < ejectedBlocks.length; i++) {
                                    previousBlock.nextConnection.connect(ejectedBlocks[i].previousConnection);
                                    previousBlock = ejectedBlocks[i];
                                }
                            }
                            if (invalidBlock) {
                                logToWebPageErrors(`⚠️ Removing non Constant block from group: Type = ${invalidBlock.type}\n`, "WARNING");
                                let groupPos = parentBlock.getRelativeToSurfaceXY();
                                let groupX = isNaN(groupPos.x) ? 50 : groupPos.x;
                                let groupY = isNaN(groupPos.y) ? 50 : groupPos.y;
                                let workspace = Blockly.getMainWorkspace();
                                let workspaceScale = workspace.scale;
                                let adjustedX = (groupX - 60) / workspaceScale;
                                let adjustedY = (groupY - 40) / workspaceScale;
                                invalidBlock.unplug();
                                invalidBlock.translate(adjustedX, adjustedY);
                                const svgGroup = invalidBlock.getSvgRoot();
                                if (svgGroup && svgGroup.parentNode) {
                                    svgGroup.parentNode.appendChild(svgGroup);
                                }
                            }
                        }
                        if (parentBlock && parentBlock.type === 'variable_block_group') {
                            let ejectedBlocks = [];
                            let invalidBlock = null;
                            let childBlock = parentBlock.getInputTargetBlock('INNER_BLOCKS');
                            while (childBlock) {
                                if (childBlock.type === "numeric_variable" || childBlock.type === "string_variable") {
                                    ejectedBlocks.push(childBlock);
                                } else {
                                    invalidBlock = childBlock;
                                }
                                childBlock = childBlock.getNextBlock() ? childBlock.getNextBlock() : null;
                            }
                            if (ejectedBlocks.length > 0) {
                                let firstBlock = ejectedBlocks[0];
                                parentBlock.getInputTargetBlock('INNER_BLOCKS').nextConnection.connect(firstBlock.previousConnection);
                                let previousBlock = firstBlock;
                                for (let i = 1; i < ejectedBlocks.length; i++) {
                                    previousBlock.nextConnection.connect(ejectedBlocks[i].previousConnection);
                                    previousBlock = ejectedBlocks[i];
                                }
                            }
                            if (invalidBlock) {
                                logToWebPageErrors(`⚠️ Removing non Variable block from group: Type = ${invalidBlock.type}\n`, "WARNING");
                                let groupPos = parentBlock.getRelativeToSurfaceXY();
                                let groupX = isNaN(groupPos.x) ? 50 : groupPos.x;
                                let groupY = isNaN(groupPos.y) ? 50 : groupPos.y;
                                let workspace = Blockly.getMainWorkspace();
                                let workspaceScale = workspace.scale;
                                let adjustedX = (groupX - 60) / workspaceScale;
                                let adjustedY = (groupY - 40) / workspaceScale;
                                invalidBlock.unplug();
                                invalidBlock.translate(adjustedX, adjustedY);
                                const svgGroup = invalidBlock.getSvgRoot();
                                if (svgGroup && svgGroup.parentNode) {
                                    svgGroup.parentNode.appendChild(svgGroup);
                                }
                            }
                        }
                    }
                });
            } else {
                console.error("Blockly workspace is not initialized yet!");
            }

            makeDraggable(document.querySelector("#consoleContainer > div:first-child"));
            makeDraggable(document.querySelector("#consoleContainer > div:last-child"));
            document.addEventListener("keydown", function (event) {
                if (event.key === "F5" || event.keyCode === 116) {
                    event.preventDefault();
                    logToWebPageErrors("⚠️ Refresh disabled during Blockly session.\n", "WARNING");
                }
            });
            document.addEventListener("keydown", function (event) {
                if (event.key === "F6" || event.keyCode === 117) {
                    event.preventDefault();
                    runCode();
                    logToWebPageErrors("Generated code via F6 key.\n");
                }
            });
            // Removed populateChipDropdown call and related logic
        }
        //// Window Onload and Event Listeners
        //window.onload = () => {
        //    console.log("Initializing Blockly workspace...");
        //    try {

        //        //console.log(Object.keys(Blockly).filter(key =>
        //        //    Blockly[key] && typeof Blockly[key] === 'object' &&
        //        //    Blockly[key].blockToCode
        //        //));

        //        //console.log("Registered blocks:", Object.keys(Blockly.Blocks));

        //        workspace = Blockly.inject('blocklyDiv', {
        //            toolbox: document.getElementById('toolbox'),
        //            grid: {
        //                spacing: 10,   // Reduced spacing for subtlety
        //                length: 2,     // Smaller grid crosses
        //                colour: '#ccc',// Lighter color for less prominence
        //                snap: true     // Enables snapping to grid
        //            },
        //            zoom: {
        //                controls: true, // Enables zoom controls
        //                wheel: true,    // Enables zoom with mouse wheel
        //                startScale: 1.0,// Initial zoom scale
        //                maxScale: 3,    // Maximum zoom scale
        //                minScale: 0.3,  // Minimum zoom scale
        //                scaleSpeed: 1.2 // Speed of zoom
        //            },
        //            move: {
        //                scrollbars: true, // Ensures scrollbars are enabled
        //                drag: true       // Allows dragging the workspace
        //            }
        //        });
        //        document.getElementById('runButton').disabled = false;
        //        document.getElementById('toggleGridButton').textContent = 'Toggle Grid (On)'; // Set initial button text

        //        // Ensure workspace is fully rendered before resizing
        //        setTimeout(() => {
        //            const blocklyDiv = document.getElementById('blocklyDiv');
        //            const gridSize = 10; // Match grid spacing
        //            new ResizeObserver(() => {
        //                const width = blocklyDiv.offsetWidth;
        //                const height = blocklyDiv.offsetHeight;
        //                const snappedWidth = Math.round(width / gridSize) * gridSize;
        //                const snappedHeight = Math.round(height / gridSize) * gridSize;
        //                blocklyDiv.style.width = `${snappedWidth}px`;
        //                blocklyDiv.style.height = `${snappedHeight}px`;
        //                Blockly.svgResize(workspace);
        //            }).observe(blocklyDiv);
        //            Blockly.svgResize(workspace); // Force initial render
        //            workspace.resize(); // Explicitly trigger resize to ensure grid renders
        //        }, 100); // Small delay to ensure DOM is ready

        //        loadDefaultXML();
        //    } catch (error) {
        //        console.error("Error initializing Blockly:", error);
        //        logToWebPageErrors(`Error: Blockly initialization failed: ${error.message}\n`, "ERROR");
        //    }
        //    if (workspace) {
        //        workspace.addChangeListener(event => {
        //            if (event.type === Blockly.Events.BLOCK_CREATE) {
        //                var block = workspace.getBlockById(event.blockId);
        //                if (block && (block.type === 'get_variable' || block.type === 'set_variable')) {
        //                    var varName = "myVar";
        //                    var exists = workspace.getAllBlocks().some(b =>
        //                        b.type === 'numeric_variable' && b.getFieldValue("VAR_NAME") === varName
        //                    );
        //                    if (!exists) {
        //                        var newBlock = workspace.newBlock('numeric_variable');
        //                        newBlock.setFieldValue(varName, "VAR_NAME");
        //                        newBlock.initSvg();
        //                        newBlock.render();
        //                        newBlock.moveBy(100, 100);
        //                    }
        //                }
        //            }
        //        });
        //        workspace.addChangeListener(function (event) {
        //            var affectedBlock = workspace.getBlockById(event.blockId);
        //            if (affectedBlock) {
        //                var parentBlock = affectedBlock.getSurroundParent();
        //                if (parentBlock && parentBlock.type === 'constant_block_group') {
        //                    let ejectedBlocks = [];
        //                    let invalidBlock = null;
        //                    let childBlock = parentBlock.getInputTargetBlock('INNER_BLOCKS');
        //                    while (childBlock) {
        //                        if (childBlock.type === "define_constant") {
        //                            ejectedBlocks.push(childBlock);
        //                        } else {
        //                            invalidBlock = childBlock;
        //                        }
        //                        childBlock = childBlock.getNextBlock() ? childBlock.getNextBlock() : null;
        //                    }
        //                    if (ejectedBlocks.length > 0) {
        //                        let firstBlock = ejectedBlocks[0];
        //                        parentBlock.getInputTargetBlock('INNER_BLOCKS').nextConnection.connect(firstBlock.previousConnection);
        //                        let previousBlock = firstBlock;
        //                        for (let i = 1; i < ejectedBlocks.length; i++) {
        //                            previousBlock.nextConnection.connect(ejectedBlocks[i].previousConnection);
        //                            previousBlock = ejectedBlocks[i];
        //                        }
        //                    }
        //                    if (invalidBlock) {
        //                        logToWebPageErrors(`⚠️ Removing non Constant block from group: Type = ${invalidBlock.type}\n`, "WARNING");
        //                        let groupPos = parentBlock.getRelativeToSurfaceXY();
        //                        let groupX = isNaN(groupPos.x) ? 50 : groupPos.x;
        //                        let groupY = isNaN(groupPos.y) ? 50 : groupPos.y;
        //                        let workspace = Blockly.getMainWorkspace();
        //                        let workspaceScale = workspace.scale;
        //                        let adjustedX = (groupX - 60) / workspaceScale;
        //                        let adjustedY = (groupY - 40) / workspaceScale;
        //                        invalidBlock.unplug();
        //                        invalidBlock.translate(adjustedX, adjustedY);
        //                        const svgGroup = invalidBlock.getSvgRoot();
        //                        if (svgGroup && svgGroup.parentNode) {
        //                            svgGroup.parentNode.appendChild(svgGroup);
        //                        }
        //                    }
        //                }
        //            }
        //        });
        //    } else {
        //        console.error("Blockly workspace is not initialized yet!");
        //    }
        //    makeDraggable(document.querySelector("#consoleContainer > div:first-child"));
        //    makeDraggable(document.querySelector("#consoleContainer > div:last-child"));

        //    // Hook F5 key
        //    document.addEventListener("keydown", function (event) {
        //        if (event.key === "F5" || event.keyCode === 116) {
        //            event.preventDefault();
        //            logToWebPageErrors("⚠️ Refresh disabled during Blockly session.\n", "WARNING");
        //        }
        //    });

        //    // Hook F6 key to Generate Code button
        //    document.addEventListener("keydown", function (event) {
        //        if (event.key === "F6" || event.keyCode === 117) {
        //            event.preventDefault(); // Prevent default browser behavior
        //            runCode(); // Call the Generate Code function
        //            logToWebPageErrors("Generated code via F6 key.\n"); // Optional feedback
        //        }
        //    });

        //    populateChipDropdown();



        //};

        Blockly.ContextMenuRegistry.registry.register({
            id: 'tight_cleanup',
            weight: 100,
            preconditionFn: function () {
                return 'enabled';
            },
            callback: function () {
                tightCleanup(Blockly.getMainWorkspace());
            },
            scopeType: Blockly.ContextMenuRegistry.ScopeType.WORKSPACE,
            displayText: "Tight Cleanup",
        });

        const chipData = [
    {
        "name": "10F200",
        "clock": 4
    },
    {
        "name": "10F202",
        "clock": 4
    },
    {
        "name": "10F204",
        "clock": 4
    },
    {
        "name": "10F206",
        "clock": 4
    },
    {
        "name": "10F220",
        "clock": 4
    },
    {
        "name": "10F222",
        "clock": 4
    },
    {
        "name": "10F320",
        "clock": 4
    },
    {
        "name": "10F322",
        "clock": 4
    },
    {
        "name": "10LF320",
        "clock": 4
    },
    {
        "name": "10LF322",
        "clock": 4
    },
    {
        "name": "12C508",
        "clock": 4
    },
    {
        "name": "12C508A",
        "clock": 4
    },
    {
        "name": "12C509",
        "clock": 4
    },
    {
        "name": "12C509A",
        "clock": 4
    },
    {
        "name": "12C671",
        "clock": 20
    },
    {
        "name": "12C672",
        "clock": 20
    },
    {
        "name": "12CE518",
        "clock": 4
    },
    {
        "name": "12CE519",
        "clock": 4
    },
    {
        "name": "12CE673",
        "clock": 20
    },
    {
        "name": "12CE674",
        "clock": 20
    },
    {
        "name": "12CR509A",
        "clock": 4
    },
    {
        "name": "12F1501",
        "clock": 4
    },
    {
        "name": "12F1571",
        "clock": 4
    },
    {
        "name": "12F1572",
        "clock": 4
    },
    {
        "name": "12F1612",
        "clock": 4
    },
    {
        "name": "12F1822",
        "clock": 4
    },
    {
        "name": "12F1840",
        "clock": 4
    },
    {
        "name": "12F508",
        "clock": 4
    },
    {
        "name": "12F509",
        "clock": 4
    },
    {
        "name": "12F510",
        "clock": 4
    },
    {
        "name": "12F519",
        "clock": 4
    },
    {
        "name": "12F520",
        "clock": 4
    },
    {
        "name": "12F529T39A",
        "clock": 4
    },
    {
        "name": "12F529T48A",
        "clock": 4
    },
    {
        "name": "12F609",
        "clock": 4
    },
    {
        "name": "12F615",
        "clock": 4
    },
    {
        "name": "12F617",
        "clock": 4
    },
    {
        "name": "12F629",
        "clock": 4
    },
    {
        "name": "12F635",
        "clock": 4
    },
    {
        "name": "12F675",
        "clock": 4
    },
    {
        "name": "12F683",
        "clock": 4
    },
    {
        "name": "12F752",
        "clock": 4
    },
    {
        "name": "12HV609",
        "clock": 4
    },
    {
        "name": "12HV615",
        "clock": 4
    },
    {
        "name": "12HV752",
        "clock": 4
    },
    {
        "name": "12LF1501",
        "clock": 4
    },
    {
        "name": "12LF1552",
        "clock": 4
    },
    {
        "name": "12LF1571",
        "clock": 4
    },
    {
        "name": "12LF1572",
        "clock": 4
    },
    {
        "name": "12LF1612",
        "clock": 4
    },
    {
        "name": "12LF1822",
        "clock": 4
    },
    {
        "name": "12LF1840",
        "clock": 4
    },
    {
        "name": "12LF1840T39A",
        "clock": 4
    },
    {
        "name": "12LF1840T48A",
        "clock": 4
    },
    {
        "name": "16C432",
        "clock": 20
    },
    {
        "name": "16C433",
        "clock": 4
    },
    {
        "name": "16C505",
        "clock": 20
    },
    {
        "name": "16C52",
        "clock": 4
    },
    {
        "name": "16C54",
        "clock": 20
    },
    {
        "name": "16C54A",
        "clock": 20
    },
    {
        "name": "16C54B",
        "clock": 4
    },
    {
        "name": "16C54C",
        "clock": 20
    },
    {
        "name": "16C55",
        "clock": 20
    },
    {
        "name": "16C554",
        "clock": 20
    },
    {
        "name": "16C557",
        "clock": 20
    },
    {
        "name": "16C558",
        "clock": 20
    },
    {
        "name": "16C55A",
        "clock": 20
    },
    {
        "name": "16C56",
        "clock": 20
    },
    {
        "name": "16C56A",
        "clock": 20
    },
    {
        "name": "16C57",
        "clock": 20
    },
    {
        "name": "16C57C",
        "clock": 20
    },
    {
        "name": "16C58A",
        "clock": 20
    },
    {
        "name": "16C58B",
        "clock": 20
    },
    {
        "name": "16C61",
        "clock": 20
    },
    {
        "name": "16C62",
        "clock": 20
    },
    {
        "name": "16C620",
        "clock": 20
    },
    {
        "name": "16C620A",
        "clock": 20
    },
    {
        "name": "16C621",
        "clock": 20
    },
    {
        "name": "16C621A",
        "clock": 20
    },
    {
        "name": "16C622",
        "clock": 20
    },
    {
        "name": "16C622A",
        "clock": 20
    },
    {
        "name": "16C62A",
        "clock": 20
    },
    {
        "name": "16C62B",
        "clock": 20
    },
    {
        "name": "16C63",
        "clock": 20
    },
    {
        "name": "16C63A",
        "clock": 20
    },
    {
        "name": "16C64",
        "clock": 20
    },
    {
        "name": "16C642",
        "clock": 20
    },
    {
        "name": "16C64A",
        "clock": 20
    },
    {
        "name": "16C65",
        "clock": 20
    },
    {
        "name": "16C65A",
        "clock": 20
    },
    {
        "name": "16C65B",
        "clock": 20
    },
    {
        "name": "16C66",
        "clock": 20
    },
    {
        "name": "16C662",
        "clock": 20
    },
    {
        "name": "16C67",
        "clock": 20
    },
    {
        "name": "16C71",
        "clock": 20
    },
    {
        "name": "16C710",
        "clock": 20
    },
    {
        "name": "16C711",
        "clock": 20
    },
    {
        "name": "16C712",
        "clock": 20
    },
    {
        "name": "16C715",
        "clock": 20
    },
    {
        "name": "16C716",
        "clock": 20
    },
    {
        "name": "16C717",
        "clock": 4
    },
    {
        "name": "16C72",
        "clock": 20
    },
    {
        "name": "16C72A",
        "clock": 20
    },
    {
        "name": "16C73",
        "clock": 20
    },
    {
        "name": "16C73A",
        "clock": 20
    },
    {
        "name": "16C73B",
        "clock": 20
    },
    {
        "name": "16C74",
        "clock": 20
    },
    {
        "name": "16C745",
        "clock": 20
    },
    {
        "name": "16C74A",
        "clock": 20
    },
    {
        "name": "16C74B",
        "clock": 20
    },
    {
        "name": "16C76",
        "clock": 20
    },
    {
        "name": "16C765",
        "clock": 20
    },
    {
        "name": "16C77",
        "clock": 20
    },
    {
        "name": "16C770",
        "clock": 4
    },
    {
        "name": "16C771",
        "clock": 20
    },
    {
        "name": "16C773",
        "clock": 20
    },
    {
        "name": "16C774",
        "clock": 20
    },
    {
        "name": "16C781",
        "clock": 4
    },
    {
        "name": "16C782",
        "clock": 4
    },
    {
        "name": "16C84",
        "clock": 20
    },
    {
        "name": "16C923",
        "clock": 20
    },
    {
        "name": "16C924",
        "clock": 20
    },
    {
        "name": "16C925",
        "clock": 20
    },
    {
        "name": "16C926",
        "clock": 20
    },
    {
        "name": "16CE623",
        "clock": 20
    },
    {
        "name": "16CE624",
        "clock": 20
    },
    {
        "name": "16CE625",
        "clock": 20
    },
    {
        "name": "16CR54",
        "clock": 20
    },
    {
        "name": "16CR54A",
        "clock": 20
    },
    {
        "name": "16CR54B",
        "clock": 20
    },
    {
        "name": "16CR54C",
        "clock": 20
    },
    {
        "name": "16CR56A",
        "clock": 20
    },
    {
        "name": "16CR57A",
        "clock": 20
    },
    {
        "name": "16CR57B",
        "clock": 20
    },
    {
        "name": "16CR57C",
        "clock": 20
    },
    {
        "name": "16CR58A",
        "clock": 20
    },
    {
        "name": "16CR58B",
        "clock": 20
    },
    {
        "name": "16CR62",
        "clock": 20
    },
    {
        "name": "16CR620A",
        "clock": 20
    },
    {
        "name": "16CR63",
        "clock": 20
    },
    {
        "name": "16CR64",
        "clock": 20
    },
    {
        "name": "16CR65",
        "clock": 20
    },
    {
        "name": "16CR72",
        "clock": 20
    },
    {
        "name": "16CR73",
        "clock": 20
    },
    {
        "name": "16CR74",
        "clock": 20
    },
    {
        "name": "16CR76",
        "clock": 20
    },
    {
        "name": "16CR77",
        "clock": 20
    },
    {
        "name": "16CR83",
        "clock": 20
    },
    {
        "name": "16CR84",
        "clock": 20
    },
    {
        "name": "16CR926",
        "clock": 4
    },
    {
        "name": "16F13113",
        "clock": 32
    },
    {
        "name": "16F13114",
        "clock": 32
    },
    {
        "name": "16F13115",
        "clock": 32
    },
    {
        "name": "16F13123",
        "clock": 32
    },
    {
        "name": "16F13124",
        "clock": 32
    },
    {
        "name": "16F13125",
        "clock": 32
    },
    {
        "name": "16F13143",
        "clock": 32
    },
    {
        "name": "16F13144",
        "clock": 32
    },
    {
        "name": "16F13145",
        "clock": 32
    },
    {
        "name": "16F1454",
        "clock": 4
    },
    {
        "name": "16F1455",
        "clock": 4
    },
    {
        "name": "16F1458",
        "clock": 4
    },
    {
        "name": "16F1459",
        "clock": 4
    },
    {
        "name": "16F1503",
        "clock": 4
    },
    {
        "name": "16F1507",
        "clock": 4
    },
    {
        "name": "16F1508",
        "clock": 4
    },
    {
        "name": "16F1509",
        "clock": 4
    },
    {
        "name": "16F1512",
        "clock": 4
    },
    {
        "name": "16F1513",
        "clock": 4
    },
    {
        "name": "16F1516",
        "clock": 4
    },
    {
        "name": "16F1517",
        "clock": 4
    },
    {
        "name": "16F1518",
        "clock": 4
    },
    {
        "name": "16F1519",
        "clock": 4
    },
    {
        "name": "16F15213",
        "clock": 32
    },
    {
        "name": "16F15214",
        "clock": 32
    },
    {
        "name": "16F15223",
        "clock": 32
    },
    {
        "name": "16F15224",
        "clock": 32
    },
    {
        "name": "16F15225",
        "clock": 32
    },
    {
        "name": "16F15243",
        "clock": 32
    },
    {
        "name": "16F15244",
        "clock": 32
    },
    {
        "name": "16F15245",
        "clock": 32
    },
    {
        "name": "16F15254",
        "clock": 32
    },
    {
        "name": "16F15255",
        "clock": 32
    },
    {
        "name": "16F15256",
        "clock": 32
    },
    {
        "name": "16F1526",
        "clock": 4
    },
    {
        "name": "16F1527",
        "clock": 4
    },
    {
        "name": "16F15274",
        "clock": 32
    },
    {
        "name": "16F15275",
        "clock": 32
    },
    {
        "name": "16F15276",
        "clock": 32
    },
    {
        "name": "16F15313",
        "clock": 32
    },
    {
        "name": "16F15323",
        "clock": 32
    },
    {
        "name": "16F15324",
        "clock": 32
    },
    {
        "name": "16F15325",
        "clock": 32
    },
    {
        "name": "16F15344",
        "clock": 32
    },
    {
        "name": "16F15345",
        "clock": 32
    },
    {
        "name": "16F15354",
        "clock": 32
    },
    {
        "name": "16F15355",
        "clock": 32
    },
    {
        "name": "16F15356",
        "clock": 32
    },
    {
        "name": "16F15375",
        "clock": 32
    },
    {
        "name": "16F15376",
        "clock": 32
    },
    {
        "name": "16F15385",
        "clock": 32
    },
    {
        "name": "16F15386",
        "clock": 32
    },
    {
        "name": "16F1574",
        "clock": 4
    },
    {
        "name": "16F1575",
        "clock": 4
    },
    {
        "name": "16F1578",
        "clock": 4
    },
    {
        "name": "16F1579",
        "clock": 4
    },
    {
        "name": "16F1613",
        "clock": 4
    },
    {
        "name": "16F1614",
        "clock": 4
    },
    {
        "name": "16F1615",
        "clock": 4
    },
    {
        "name": "16F1618",
        "clock": 4
    },
    {
        "name": "16F1619",
        "clock": 4
    },
    {
        "name": "16F1703",
        "clock": 4
    },
    {
        "name": "16F1704",
        "clock": 4
    },
    {
        "name": "16F1705",
        "clock": 4
    },
    {
        "name": "16F1707",
        "clock": 4
    },
    {
        "name": "16F1708",
        "clock": 4
    },
    {
        "name": "16F1709",
        "clock": 4
    },
    {
        "name": "16F17114",
        "clock": 32
    },
    {
        "name": "16F17115",
        "clock": 32
    },
    {
        "name": "16F17124",
        "clock": 32
    },
    {
        "name": "16F17125",
        "clock": 32
    },
    {
        "name": "16F17126",
        "clock": 32
    },
    {
        "name": "16F1713",
        "clock": 4
    },
    {
        "name": "16F17144",
        "clock": 32
    },
    {
        "name": "16F17145",
        "clock": 32
    },
    {
        "name": "16F17146",
        "clock": 32
    },
    {
        "name": "16F17154",
        "clock": 32
    },
    {
        "name": "16F17155",
        "clock": 32
    },
    {
        "name": "16F17156",
        "clock": 32
    },
    {
        "name": "16F1716",
        "clock": 4
    },
    {
        "name": "16F1717",
        "clock": 4
    },
    {
        "name": "16F17174",
        "clock": 32
    },
    {
        "name": "16F17175",
        "clock": 32
    },
    {
        "name": "16F17176",
        "clock": 32
    },
    {
        "name": "16F1718",
        "clock": 4
    },
    {
        "name": "16F1719",
        "clock": 4
    },
    {
        "name": "16F1764",
        "clock": 4
    },
    {
        "name": "16F1765",
        "clock": 4
    },
    {
        "name": "16F1768",
        "clock": 4
    },
    {
        "name": "16F1769",
        "clock": 4
    },
    {
        "name": "16F1773",
        "clock": 4
    },
    {
        "name": "16F1776",
        "clock": 4
    },
    {
        "name": "16F1777",
        "clock": 4
    },
    {
        "name": "16F1778",
        "clock": 4
    },
    {
        "name": "16F1779",
        "clock": 4
    },
    {
        "name": "16F1782",
        "clock": 4
    },
    {
        "name": "16F1783",
        "clock": 4
    },
    {
        "name": "16F1784",
        "clock": 4
    },
    {
        "name": "16F1786",
        "clock": 4
    },
    {
        "name": "16F1787",
        "clock": 4
    },
    {
        "name": "16F1788",
        "clock": 4
    },
    {
        "name": "16F1789",
        "clock": 4
    },
    {
        "name": "16F18013",
        "clock": 32
    },
    {
        "name": "16F18014",
        "clock": 32
    },
    {
        "name": "16F18015",
        "clock": 32
    },
    {
        "name": "16F18023",
        "clock": 32
    },
    {
        "name": "16F18024",
        "clock": 32
    },
    {
        "name": "16F18025",
        "clock": 32
    },
    {
        "name": "16F18026",
        "clock": 32
    },
    {
        "name": "16F18044",
        "clock": 32
    },
    {
        "name": "16F18045",
        "clock": 32
    },
    {
        "name": "16F18046",
        "clock": 32
    },
    {
        "name": "16F18054",
        "clock": 32
    },
    {
        "name": "16F18055",
        "clock": 32
    },
    {
        "name": "16F18056",
        "clock": 32
    },
    {
        "name": "16F873",
        "clock": 20
    },
    {
        "name": "16F873A",
        "clock": 20
    },
    {
        "name": "16F874",
        "clock": 20
    },
    {
        "name": "16F874A",
        "clock": 20
    },
    {
        "name": "16F876",
        "clock": 20
    },
    {
        "name": "16F876A",
        "clock": 20
    },
    {
        "name": "16F877",
        "clock": 20
    },
    {
        "name": "16F877A",
        "clock": 20
    },
    {
        "name": "16F88",
        "clock": 4
    },
    {
        "name": "16F882",
        "clock": 4
    },
    {
        "name": "16F883",
        "clock": 4
    },
    {
        "name": "16F884",
        "clock": 4
    },
    {
        "name": "16F886",
        "clock": 4
    },
    {
        "name": "16F887",
        "clock": 4
    },
    {
        "name": "16F913",
        "clock": 4
    },
    {
        "name": "16F914",
        "clock": 4
    },
    {
        "name": "16F916",
        "clock": 4
    },
    {
        "name": "16F917",
        "clock": 4
    },
    {
        "name": "16F946",
        "clock": 4
    },
    {
        "name": "16HV540",
        "clock": 20
    },
    {
        "name": "16HV610",
        "clock": 4
    },
    {
        "name": "16HV616",
        "clock": 4
    },
    {
        "name": "16HV753",
        "clock": 4
    },
    {
        "name": "16HV785",
        "clock": 4
    },
    {
        "name": "16LF1454",
        "clock": 4
    },
    {
        "name": "16LF1455",
        "clock": 4
    },
    {
        "name": "16LF1458",
        "clock": 4
    },
    {
        "name": "16LF1459",
        "clock": 4
    },
    {
        "name": "16LF1503",
        "clock": 4
    },
    {
        "name": "16LF1507",
        "clock": 4
    },
    {
        "name": "16LF1508",
        "clock": 4
    },
    {
        "name": "16LF1509",
        "clock": 4
    },
    {
        "name": "16LF1512",
        "clock": 4
    },
    {
        "name": "16LF1513",
        "clock": 4
    },
    {
        "name": "16LF1516",
        "clock": 4
    },
    {
        "name": "16LF1517",
        "clock": 4
    },
    {
        "name": "16LF1518",
        "clock": 4
    },
    {
        "name": "16LF1519",
        "clock": 4
    },
    {
        "name": "16LF1526",
        "clock": 4
    },
    {
        "name": "16LF1527",
        "clock": 4
    },
    {
        "name": "16LF15313",
        "clock": 32
    },
    {
        "name": "16LF15323",
        "clock": 32
    },
    {
        "name": "16LF15324",
        "clock": 32
    },
    {
        "name": "16LF15325",
        "clock": 32
    },
    {
        "name": "16LF15344",
        "clock": 32
    },
    {
        "name": "16LF15345",
        "clock": 32
    },
    {
        "name": "16LF15354",
        "clock": 32
    },
    {
        "name": "16LF15355",
        "clock": 32
    },
    {
        "name": "16LF15356",
        "clock": 32
    },
    {
        "name": "16LF15375",
        "clock": 32
    },
    {
        "name": "16LF15376",
        "clock": 32
    },
    {
        "name": "16LF15385",
        "clock": 32
    },
    {
        "name": "16LF15386",
        "clock": 32
    },
    {
        "name": "16LF1554",
        "clock": 4
    },
    {
        "name": "16LF1559",
        "clock": 4
    },
    {
        "name": "16LF1566",
        "clock": 4
    },
    {
        "name": "16LF1567",
        "clock": 4
    },
    {
        "name": "16LF1574",
        "clock": 4
    },
    {
        "name": "16LF1575",
        "clock": 4
    },
    {
        "name": "16LF1578",
        "clock": 4
    },
    {
        "name": "16LF1579",
        "clock": 4
    },
    {
        "name": "16LF1613",
        "clock": 4
    },
    {
        "name": "16LF1614",
        "clock": 4
    },
    {
        "name": "16LF1615",
        "clock": 4
    },
    {
        "name": "16LF1618",
        "clock": 4
    },
    {
        "name": "16LF1619",
        "clock": 4
    },
    {
        "name": "16LF1703",
        "clock": 4
    },
    {
        "name": "16LF1704",
        "clock": 4
    },
    {
        "name": "16LF1705",
        "clock": 4
    },
    {
        "name": "16LF1707",
        "clock": 4
    },
    {
        "name": "16LF1708",
        "clock": 4
    },
    {
        "name": "16LF1709",
        "clock": 4
    },
    {
        "name": "16LF1713",
        "clock": 4
    },
    {
        "name": "16LF1716",
        "clock": 4
    },
    {
        "name": "16LF1717",
        "clock": 4
    },
    {
        "name": "16LF1718",
        "clock": 4
    },
    {
        "name": "16LF1719",
        "clock": 4
    },
    {
        "name": "16LF1764",
        "clock": 4
    },
    {
        "name": "16LF1765",
        "clock": 4
    },
    {
        "name": "16LF1768",
        "clock": 4
    },
    {
        "name": "16LF1769",
        "clock": 4
    },
    {
        "name": "16LF1773",
        "clock": 4
    },
    {
        "name": "16LF1776",
        "clock": 4
    },
    {
        "name": "16LF1777",
        "clock": 4
    },
    {
        "name": "16LF1778",
        "clock": 4
    },
    {
        "name": "16LF1779",
        "clock": 4
    },
    {
        "name": "16LF1782",
        "clock": 4
    },
    {
        "name": "16LF1783",
        "clock": 4
    },
    {
        "name": "16LF1784",
        "clock": 4
    },
    {
        "name": "16LF1786",
        "clock": 4
    },
    {
        "name": "16LF1787",
        "clock": 4
    },
    {
        "name": "16LF1788",
        "clock": 4
    },
    {
        "name": "16LF1789",
        "clock": 4
    },
    {
        "name": "16LF1823",
        "clock": 4
    },
    {
        "name": "16LF1824",
        "clock": 4
    },
    {
        "name": "16LF1824T39A",
        "clock": 4
    },
    {
        "name": "16LF1825",
        "clock": 4
    },
    {
        "name": "16LF1826",
        "clock": 4
    },
    {
        "name": "16LF1827",
        "clock": 4
    },
    {
        "name": "16LF1828",
        "clock": 4
    },
    {
        "name": "16LF1829",
        "clock": 4
    },
    {
        "name": "16LF18313",
        "clock": 32
    },
    {
        "name": "16LF18323",
        "clock": 32
    },
    {
        "name": "16LF18324",
        "clock": 32
    },
    {
        "name": "16LF18325",
        "clock": 32
    },
    {
        "name": "16LF18326",
        "clock": 32
    },
    {
        "name": "16LF18344",
        "clock": 32
    },
    {
        "name": "16LF18345",
        "clock": 32
    },
    {
        "name": "16LF18346",
        "clock": 32
    },
    {
        "name": "16LF18424",
        "clock": 32
    },
    {
        "name": "16LF18425",
        "clock": 32
    },
    {
        "name": "16LF18426",
        "clock": 32
    },
    {
        "name": "16LF18444",
        "clock": 32
    },
    {
        "name": "16LF18445",
        "clock": 32
    },
    {
        "name": "16LF18446",
        "clock": 32
    },
    {
        "name": "16LF18455",
        "clock": 32
    },
    {
        "name": "16LF18456",
        "clock": 32
    },
    {
        "name": "16LF1847",
        "clock": 4
    },
    {
        "name": "16LF18854",
        "clock": 32
    },
    {
        "name": "16LF18855",
        "clock": 32
    },
    {
        "name": "16LF18856",
        "clock": 32
    },
    {
        "name": "16LF18857",
        "clock": 32
    },
    {
        "name": "16LF18875",
        "clock": 32
    },
    {
        "name": "16LF18876",
        "clock": 32
    },
    {
        "name": "16LF18877",
        "clock": 32
    },
    {
        "name": "16LF1902",
        "clock": 4
    },
    {
        "name": "16LF1903",
        "clock": 4
    },
    {
        "name": "16LF1904",
        "clock": 4
    },
    {
        "name": "16LF1906",
        "clock": 4
    },
    {
        "name": "16LF1907",
        "clock": 4
    },
    {
        "name": "16LF19155",
        "clock": 32
    },
    {
        "name": "16LF19156",
        "clock": 32
    },
    {
        "name": "16LF19175",
        "clock": 32
    },
    {
        "name": "16LF19176",
        "clock": 32
    },
    {
        "name": "16LF19185",
        "clock": 32
    },
    {
        "name": "16LF19186",
        "clock": 32
    },
    {
        "name": "16LF19195",
        "clock": 32
    },
    {
        "name": "16LF19196",
        "clock": 32
    },
    {
        "name": "16LF19197",
        "clock": 32
    },
    {
        "name": "16LF1933",
        "clock": 4
    },
    {
        "name": "16LF1934",
        "clock": 4
    },
    {
        "name": "16LF1936",
        "clock": 4
    },
    {
        "name": "16LF1937",
        "clock": 4
    },
    {
        "name": "16LF1938",
        "clock": 4
    },
    {
        "name": "16LF1939",
        "clock": 4
    },
    {
        "name": "16LF1946",
        "clock": 4
    },
    {
        "name": "16LF1947",
        "clock": 4
    },
    {
        "name": "16LF627",
        "clock": 4
    },
    {
        "name": "16LF627A",
        "clock": 4
    },
    {
        "name": "16LF628",
        "clock": 4
    },
    {
        "name": "16LF628A",
        "clock": 4
    },
    {
        "name": "16LF648A",
        "clock": 4
    },
    {
        "name": "16LF707",
        "clock": 4
    },
    {
        "name": "16LF720",
        "clock": 4
    },
    {
        "name": "16LF721",
        "clock": 4
    },
    {
        "name": "16LF722",
        "clock": 4
    },
    {
        "name": "16LF722A",
        "clock": 4
    },
    {
        "name": "16LF723",
        "clock": 4
    },
    {
        "name": "16LF723A",
        "clock": 4
    },
    {
        "name": "16LF724",
        "clock": 4
    },
    {
        "name": "16LF726",
        "clock": 4
    },
    {
        "name": "16LF727",
        "clock": 4
    },
    {
        "name": "16LF73",
        "clock": 20
    },
    {
        "name": "16LF74",
        "clock": 20
    },
    {
        "name": "16LF747",
        "clock": 4
    },
    {
        "name": "16LF76",
        "clock": 20
    },
    {
        "name": "16LF767",
        "clock": 4
    },
    {
        "name": "16LF77",
        "clock": 20
    },
    {
        "name": "16LF777",
        "clock": 4
    },
    {
        "name": "16LF818",
        "clock": 4
    },
    {
        "name": "16LF819",
        "clock": 4
    },
    {
        "name": "16LF83",
        "clock": 20
    },
    {
        "name": "16LF84",
        "clock": 20
    },
    {
        "name": "16LF84A",
        "clock": 20
    },
    {
        "name": "16LF87",
        "clock": 4
    },
    {
        "name": "16LF870",
        "clock": 20
    },
    {
        "name": "16LF871",
        "clock": 20
    },
    {
        "name": "16LF872",
        "clock": 20
    },
    {
        "name": "16LF873",
        "clock": 20
    },
    {
        "name": "16LF873A",
        "clock": 20
    },
    {
        "name": "16LF874",
        "clock": 20
    },
    {
        "name": "16LF874A",
        "clock": 20
    },
    {
        "name": "16LF876",
        "clock": 20
    },
    {
        "name": "16LF876A",
        "clock": 20
    },
    {
        "name": "16LF877",
        "clock": 20
    },
    {
        "name": "16LF877A",
        "clock": 20
    },
    {
        "name": "16LF88",
        "clock": 4
    },
    {
        "name": "18C242",
        "clock": 20
    },
    {
        "name": "18C252",
        "clock": 20
    },
    {
        "name": "18C442",
        "clock": 20
    },
    {
        "name": "18C452",
        "clock": 20
    },
    {
        "name": "18C601",
        "clock": 20
    },
    {
        "name": "18C658",
        "clock": 20
    },
    {
        "name": "18C801",
        "clock": 20
    },
    {
        "name": "18C858",
        "clock": 20
    },
    {
        "name": "18F04Q20",
        "clock": 1
    },
    {
        "name": "18F04Q40",
        "clock": 1
    },
    {
        "name": "18F04Q41",
        "clock": 1
    },
    {
        "name": "18F05Q20",
        "clock": 1
    },
    {
        "name": "18F05Q40",
        "clock": 1
    },
    {
        "name": "18F05Q41",
        "clock": 1
    },
    {
        "name": "18F06Q20",
        "clock": 1
    },
    {
        "name": "18F06Q40",
        "clock": 1
    },
    {
        "name": "18F06Q41",
        "clock": 1
    },
    {
        "name": "18F1220",
        "clock": 4
    },
    {
        "name": "18F1230",
        "clock": 4
    },
    {
        "name": "18F1320",
        "clock": 4
    },
    {
        "name": "18F1330",
        "clock": 4
    },
    {
        "name": "18F13K22",
        "clock": 4
    },
    {
        "name": "18F13K50",
        "clock": 4
    },
    {
        "name": "18F14K22",
        "clock": 4
    },
    {
        "name": "18F14K22LIN",
        "clock": 4
    },
    {
        "name": "18F14K50",
        "clock": 4
    },
    {
        "name": "18F14Q20",
        "clock": 1
    },
    {
        "name": "18F14Q40",
        "clock": 1
    },
    {
        "name": "18F14Q41",
        "clock": 1
    },
    {
        "name": "18F15Q20",
        "clock": 1
    },
    {
        "name": "18F15Q40",
        "clock": 1
    },
    {
        "name": "18F15Q41",
        "clock": 1
    },
    {
        "name": "18F16Q20",
        "clock": 1
    },
    {
        "name": "18F16Q40",
        "clock": 1
    },
    {
        "name": "18F16Q41",
        "clock": 1
    },
    {
        "name": "18F2220",
        "clock": 4
    },
    {
        "name": "18F2221",
        "clock": 4
    },
    {
        "name": "18F2320",
        "clock": 4
    },
    {
        "name": "18F2321",
        "clock": 4
    },
    {
        "name": "18F2331",
        "clock": 4
    },
    {
        "name": "18F23K20",
        "clock": 4
    },
    {
        "name": "18F23K22",
        "clock": 4
    },
    {
        "name": "18F2410",
        "clock": 4
    },
    {
        "name": "18F242",
        "clock": 20
    },
    {
        "name": "18F2420",
        "clock": 4
    },
    {
        "name": "18F2423",
        "clock": 4
    },
    {
        "name": "18F2431",
        "clock": 4
    },
    {
        "name": "18F2439",
        "clock": 20
    },
    {
        "name": "18F2450",
        "clock": 4
    },
    {
        "name": "18F2455",
        "clock": 4
    },
    {
        "name": "18F2458",
        "clock": 4
    },
    {
        "name": "18F248",
        "clock": 20
    },
    {
        "name": "18F2480",
        "clock": 4
    },
    {
        "name": "18F24J10",
        "clock": 4
    },
    {
        "name": "18F24J11",
        "clock": 4
    },
    {
        "name": "18F24J50",
        "clock": 4
    },
    {
        "name": "18F24K20",
        "clock": 4
    },
    {
        "name": "18F24K22",
        "clock": 4
    },
    {
        "name": "18F24K40",
        "clock": 1
    },
    {
        "name": "18F24K42",
        "clock": 1
    },
    {
        "name": "18F24K50",
        "clock": 4
    },
    {
        "name": "18F24Q10",
        "clock": 1
    },
    {
        "name": "18F24Q24",
        "clock": 1
    },
    {
        "name": "18F24Q71",
        "clock": 1
    },
    {
        "name": "18F2510",
        "clock": 4
    },
    {
        "name": "18F2515",
        "clock": 4
    },
    {
        "name": "18F252",
        "clock": 20
    },
    {
        "name": "18F2520",
        "clock": 4
    },
    {
        "name": "18F2523",
        "clock": 4
    },
    {
        "name": "18F2525",
        "clock": 4
    },
    {
        "name": "18F2539",
        "clock": 20
    },
    {
        "name": "18F2550",
        "clock": 4
    },
    {
        "name": "18F2553",
        "clock": 4
    },
    {
        "name": "18F258",
        "clock": 20
    },
    {
        "name": "18F2580",
        "clock": 4
    },
    {
        "name": "18F2585",
        "clock": 4
    },
    {
        "name": "18F25J10",
        "clock": 4
    },
    {
        "name": "18F25J11",
        "clock": 4
    },
    {
        "name": "18F25J50",
        "clock": 4
    },
    {
        "name": "18F25K20",
        "clock": 4
    },
    {
        "name": "18F25K22",
        "clock": 4
    },
    {
        "name": "18F25K40",
        "clock": 1
    },
    {
        "name": "18F25K42",
        "clock": 1
    },
    {
        "name": "18F25K50",
        "clock": 4
    },
    {
        "name": "18F25K80",
        "clock": 4
    },
    {
        "name": "18F25K83",
        "clock": 1
    },
    {
        "name": "18F25Q10",
        "clock": 1
    },
    {
        "name": "18F25Q24",
        "clock": 1
    },
    {
        "name": "18F25Q43",
        "clock": 1
    },
    {
        "name": "18F25Q71",
        "clock": 1
    },
    {
        "name": "18F2610",
        "clock": 4
    },
    {
        "name": "18F2620",
        "clock": 4
    },
    {
        "name": "18F2680",
        "clock": 4
    },
    {
        "name": "18F2682",
        "clock": 4
    },
    {
        "name": "18F2685",
        "clock": 4
    },
    {
        "name": "18F26J11",
        "clock": 4
    },
    {
        "name": "18F26J13",
        "clock": 4
    },
    {
        "name": "18F26J50",
        "clock": 4
    },
    {
        "name": "18F26J53",
        "clock": 4
    },
    {
        "name": "18F26K20",
        "clock": 4
    },
    {
        "name": "18F26K22",
        "clock": 4
    },
    {
        "name": "18F26K40",
        "clock": 1
    },
    {
        "name": "18F26K42",
        "clock": 1
    },
    {
        "name": "18F26K80",
        "clock": 4
    },
    {
        "name": "18F26K83",
        "clock": 1
    },
    {
        "name": "18F26Q10",
        "clock": 1
    },
    {
        "name": "18F26Q24",
        "clock": 1
    },
    {
        "name": "18F26Q43",
        "clock": 1
    },
    {
        "name": "18F26Q71",
        "clock": 1
    },
    {
        "name": "18F26Q83",
        "clock": 1
    },
    {
        "name": "18F26Q84",
        "clock": 1
    },
    {
        "name": "18F27J13",
        "clock": 4
    },
    {
        "name": "18F27J53",
        "clock": 4
    },
    {
        "name": "18F27K40",
        "clock": 1
    },
    {
        "name": "18F27K42",
        "clock": 1
    },
    {
        "name": "18F27Q10",
        "clock": 1
    },
    {
        "name": "18F27Q43",
        "clock": 1
    },
    {
        "name": "18F27Q83",
        "clock": 1
    },
    {
        "name": "18F27Q84",
        "clock": 1
    },
    {
        "name": "18F4220",
        "clock": 4
    },
    {
        "name": "18F4221",
        "clock": 4
    },
    {
        "name": "18F4320",
        "clock": 4
    },
    {
        "name": "18F4321",
        "clock": 4
    },
    {
        "name": "18F4331",
        "clock": 4
    },
    {
        "name": "18F43K20",
        "clock": 4
    },
    {
        "name": "18F43K22",
        "clock": 4
    },
    {
        "name": "18F4410",
        "clock": 4
    },
    {
        "name": "18F442",
        "clock": 20
    },
    {
        "name": "18F4420",
        "clock": 4
    },
    {
        "name": "18F4423",
        "clock": 4
    },
    {
        "name": "18F4431",
        "clock": 4
    },
    {
        "name": "18F4439",
        "clock": 20
    },
    {
        "name": "18F4450",
        "clock": 4
    },
    {
        "name": "18F4455",
        "clock": 4
    },
    {
        "name": "18F4458",
        "clock": 4
    },
    {
        "name": "18F448",
        "clock": 20
    },
    {
        "name": "18F4480",
        "clock": 4
    },
    {
        "name": "18F44J10",
        "clock": 4
    },
    {
        "name": "18F44J11",
        "clock": 4
    },
    {
        "name": "18F44J50",
        "clock": 4
    },
    {
        "name": "18F44K20",
        "clock": 4
    },
    {
        "name": "18F44K22",
        "clock": 4
    },
    {
        "name": "18F44Q71",
        "clock": 1
    },
    {
        "name": "18F4510",
        "clock": 4
    },
    {
        "name": "18F4515",
        "clock": 4
    },
    {
        "name": "18F452",
        "clock": 20
    },
    {
        "name": "18F4520",
        "clock": 4
    },
    {
        "name": "18F4523",
        "clock": 4
    },
    {
        "name": "18F4525",
        "clock": 4
    },
    {
        "name": "18F4539",
        "clock": 20
    },
    {
        "name": "18F4550",
        "clock": 4
    },
    {
        "name": "18F4553",
        "clock": 4
    },
    {
        "name": "18F458",
        "clock": 20
    },
    {
        "name": "18F4580",
        "clock": 4
    },
    {
        "name": "18F4585",
        "clock": 4
    },
    {
        "name": "18F45J10",
        "clock": 4
    },
    {
        "name": "18F45J11",
        "clock": 4
    },
    {
        "name": "18F45J50",
        "clock": 4
    },
    {
        "name": "18F45K20",
        "clock": 4
    },
    {
        "name": "18F45K22",
        "clock": 4
    },
    {
        "name": "18F45K40",
        "clock": 1
    },
    {
        "name": "18F45K42",
        "clock": 1
    },
    {
        "name": "18F45K50",
        "clock": 4
    },
    {
        "name": "18F45K80",
        "clock": 4
    },
    {
        "name": "18F45Q10",
        "clock": 1
    },
    {
        "name": "18F45Q24",
        "clock": 1
    },
    {
        "name": "18F45Q43",
        "clock": 1
    },
    {
        "name": "18F45Q71",
        "clock": 1
    },
    {
        "name": "18F4610",
        "clock": 4
    },
    {
        "name": "18F4620",
        "clock": 4
    },
    {
        "name": "18F4680",
        "clock": 4
    },
    {
        "name": "18F4682",
        "clock": 4
    },
    {
        "name": "18F4685",
        "clock": 4
    },
    {
        "name": "18F46J11",
        "clock": 4
    },
    {
        "name": "18F46J13",
        "clock": 4
    },
    {
        "name": "18F46J50",
        "clock": 4
    },
    {
        "name": "18F46J53",
        "clock": 4
    },
    {
        "name": "18F46K20",
        "clock": 4
    },
    {
        "name": "18F46K22",
        "clock": 4
    },
    {
        "name": "18F46K40",
        "clock": 1
    },
    {
        "name": "18F46K42",
        "clock": 1
    },
    {
        "name": "18F46K80",
        "clock": 4
    },
    {
        "name": "18F46Q10",
        "clock": 1
    },
    {
        "name": "18F46Q24",
        "clock": 1
    },
    {
        "name": "18F46Q43",
        "clock": 1
    },
    {
        "name": "18F46Q71",
        "clock": 1
    },
    {
        "name": "18F46Q83",
        "clock": 1
    },
    {
        "name": "18F46Q84",
        "clock": 1
    },
    {
        "name": "18F47J13",
        "clock": 4
    },
    {
        "name": "18F47J53",
        "clock": 4
    },
    {
        "name": "18F47K40",
        "clock": 1
    },
    {
        "name": "18F47K42",
        "clock": 1
    },
    {
        "name": "18F47Q10",
        "clock": 1
    },
    {
        "name": "18F47Q43",
        "clock": 1
    },
    {
        "name": "18F47Q83",
        "clock": 1
    },
    {
        "name": "18F47Q84",
        "clock": 1
    },
    {
        "name": "18F54Q71",
        "clock": 1
    },
    {
        "name": "18F55K42",
        "clock": 1
    },
    {
        "name": "18F55Q24",
        "clock": 1
    },
    {
        "name": "18F55Q43",
        "clock": 1
    },
    {
        "name": "18F55Q71",
        "clock": 1
    },
    {
        "name": "18F56K42",
        "clock": 1
    },
    {
        "name": "18F56Q24",
        "clock": 1
    },
    {
        "name": "18F56Q43",
        "clock": 1
    },
    {
        "name": "18F56Q71",
        "clock": 1
    },
    {
        "name": "18F56Q83",
        "clock": 1
    },
    {
        "name": "18F56Q84",
        "clock": 1
    },
    {
        "name": "18F57K42",
        "clock": 1
    },
    {
        "name": "18F57Q43",
        "clock": 1
    },
    {
        "name": "18F57Q83",
        "clock": 1
    },
    {
        "name": "18F57Q84",
        "clock": 1
    },
    {
        "name": "18F6310",
        "clock": 4
    },
    {
        "name": "18F6390",
        "clock": 4
    },
    {
        "name": "18F6393",
        "clock": 4
    },
    {
        "name": "18F63J11",
        "clock": 4
    },
    {
        "name": "18F63J90",
        "clock": 4
    },
    {
        "name": "18F6410",
        "clock": 4
    },
    {
        "name": "18F6490",
        "clock": 4
    },
    {
        "name": "18F6493",
        "clock": 4
    },
    {
        "name": "18F64J11",
        "clock": 4
    },
    {
        "name": "18F64J90",
        "clock": 4
    },
    {
        "name": "18F6520",
        "clock": 20
    },
    {
        "name": "18F6525",
        "clock": 20
    },
    {
        "name": "18F6527",
        "clock": 4
    },
    {
        "name": "18F6585",
        "clock": 20
    },
    {
        "name": "18F65J10",
        "clock": 4
    },
    {
        "name": "18F65J11",
        "clock": 4
    },
    {
        "name": "18F65J15",
        "clock": 4
    },
    {
        "name": "18F65J50",
        "clock": 4
    },
    {
        "name": "18F65J90",
        "clock": 4
    },
    {
        "name": "18F65J94",
        "clock": 4
    },
    {
        "name": "18F65K22",
        "clock": 4
    },
    {
        "name": "18F65K40",
        "clock": 1
    },
    {
        "name": "18F65K80",
        "clock": 4
    },
    {
        "name": "18F65K90",
        "clock": 4
    },
    {
        "name": "18F6620",
        "clock": 20
    },
    {
        "name": "18F6621",
        "clock": 20
    },
    {
        "name": "18F6622",
        "clock": 4
    },
    {
        "name": "18F6627",
        "clock": 4
    },
    {
        "name": "18F6628",
        "clock": 4
    },
    {
        "name": "18F6680",
        "clock": 4
    },
    {
        "name": "18F66J10",
        "clock": 4
    },
    {
        "name": "18F66J11",
        "clock": 4
    },
    {
        "name": "18F66J15",
        "clock": 4
    },
    {
        "name": "18F66J16",
        "clock": 4
    },
    {
        "name": "18F66J50",
        "clock": 4
    },
    {
        "name": "18F66J55",
        "clock": 4
    },
    {
        "name": "18F66J60",
        "clock": 4
    },
    {
        "name": "18F66J65",
        "clock": 4
    },
    {
        "name": "18F66J90",
        "clock": 4
    },
    {
        "name": "18F66J93",
        "clock": 4
    },
    {
        "name": "18F66J94",
        "clock": 4
    },
    {
        "name": "18F66K22",
        "clock": 4
    },
    {
        "name": "18F66K40",
        "clock": 1
    },
    {
        "name": "18F66K80",
        "clock": 4
    },
    {
        "name": "18F66K90",
        "clock": 4
    },
    {
        "name": "18F6720",
        "clock": 20
    },
    {
        "name": "18F6722",
        "clock": 4
    },
    {
        "name": "18F6723",
        "clock": 4
    },
    {
        "name": "18F67J10",
        "clock": 4
    },
    {
        "name": "18F67J11",
        "clock": 4
    },
    {
        "name": "18F67J50",
        "clock": 4
    },
    {
        "name": "18F67J60",
        "clock": 4
    },
    {
        "name": "18F67J90",
        "clock": 4
    },
    {
        "name": "18F67J93",
        "clock": 4
    },
    {
        "name": "18F67J94",
        "clock": 4
    },
    {
        "name": "18F67K22",
        "clock": 4
    },
    {
        "name": "18F67K40",
        "clock": 1
    },
    {
        "name": "18F67K90",
        "clock": 4
    },
    {
        "name": "18F8310",
        "clock": 4
    },
    {
        "name": "18F8390",
        "clock": 4
    },
    {
        "name": "18F8393",
        "clock": 4
    },
    {
        "name": "18F83J11",
        "clock": 4
    },
    {
        "name": "18F83J90",
        "clock": 4
    },
    {
        "name": "18F8410",
        "clock": 4
    },
    {
        "name": "18F8490",
        "clock": 4
    },
    {
        "name": "18F8493",
        "clock": 4
    },
    {
        "name": "18F84J11",
        "clock": 4
    },
    {
        "name": "18F84J90",
        "clock": 4
    },
    {
        "name": "18F8520",
        "clock": 20
    },
    {
        "name": "18F8525",
        "clock": 20
    },
    {
        "name": "18F8527",
        "clock": 4
    },
    {
        "name": "18F8585",
        "clock": 20
    },
    {
        "name": "18F85J10",
        "clock": 4
    },
    {
        "name": "18F85J11",
        "clock": 4
    },
    {
        "name": "18F85J15",
        "clock": 4
    },
    {
        "name": "18F85J50",
        "clock": 4
    },
    {
        "name": "18F85J90",
        "clock": 4
    },
    {
        "name": "18F85J94",
        "clock": 4
    },
    {
        "name": "18F85K22",
        "clock": 4
    },
    {
        "name": "18F85K90",
        "clock": 4
    },
    {
        "name": "18F8620",
        "clock": 20
    },
    {
        "name": "18F8621",
        "clock": 20
    },
    {
        "name": "18F8622",
        "clock": 4
    },
    {
        "name": "18F8627",
        "clock": 4
    },
    {
        "name": "18F8628",
        "clock": 4
    },
    {
        "name": "18F8680",
        "clock": 4
    },
    {
        "name": "18F86J10",
        "clock": 4
    },
    {
        "name": "18F86J11",
        "clock": 4
    },
    {
        "name": "18F86J15",
        "clock": 4
    },
    {
        "name": "18F86J16",
        "clock": 4
    },
    {
        "name": "18F86J50",
        "clock": 4
    },
    {
        "name": "18F86J55",
        "clock": 4
    },
    {
        "name": "18F86J60",
        "clock": 4
    },
    {
        "name": "18F86J65",
        "clock": 4
    },
    {
        "name": "18F86J72",
        "clock": 4
    },
    {
        "name": "18F86J90",
        "clock": 4
    },
    {
        "name": "18F86J93",
        "clock": 4
    },
    {
        "name": "18F86J94",
        "clock": 4
    },
    {
        "name": "18F86K22",
        "clock": 4
    },
    {
        "name": "18F86K90",
        "clock": 4
    },
    {
        "name": "18F8720",
        "clock": 20
    },
    {
        "name": "18F8722",
        "clock": 4
    },
    {
        "name": "18F8723",
        "clock": 4
    },
    {
        "name": "18F87J10",
        "clock": 4
    },
    {
        "name": "18F87J11",
        "clock": 4
    },
    {
        "name": "18F87J50",
        "clock": 4
    },
    {
        "name": "18F87J60",
        "clock": 4
    },
    {
        "name": "18F87J72",
        "clock": 4
    },
    {
        "name": "18F87J90",
        "clock": 4
    },
    {
        "name": "18F87J93",
        "clock": 4
    },
    {
        "name": "18F87J94",
        "clock": 4
    },
    {
        "name": "18F87K22",
        "clock": 4
    },
    {
        "name": "18F87K90",
        "clock": 4
    },
    {
        "name": "18F95J94",
        "clock": 4
    },
    {
        "name": "18F96J60",
        "clock": 4
    },
    {
        "name": "18F96J65",
        "clock": 4
    },
    {
        "name": "18F96J94",
        "clock": 4
    },
    {
        "name": "18F97J60",
        "clock": 4
    },
    {
        "name": "18F97J94",
        "clock": 4
    },
    {
        "name": "18LF1220",
        "clock": 4
    },
    {
        "name": "18LF1230",
        "clock": 4
    },
    {
        "name": "18LF1320",
        "clock": 4
    },
    {
        "name": "18LF1330",
        "clock": 4
    },
    {
        "name": "18LF13K22",
        "clock": 4
    },
    {
        "name": "18LF13K50",
        "clock": 4
    },
    {
        "name": "18LF14K22",
        "clock": 4
    },
    {
        "name": "18LF14K50",
        "clock": 4
    },
    {
        "name": "18LF2220",
        "clock": 4
    },
    {
        "name": "18LF2221",
        "clock": 4
    },
    {
        "name": "18LF2320",
        "clock": 4
    },
    {
        "name": "18LF2321",
        "clock": 4
    },
    {
        "name": "18LF2331",
        "clock": 4
    },
    {
        "name": "18LF23K22",
        "clock": 4
    },
    {
        "name": "18LF2410",
        "clock": 4
    },
    {
        "name": "18LF242",
        "clock": 20
    },
    {
        "name": "18LF2420",
        "clock": 4
    },
    {
        "name": "18LF2423",
        "clock": 4
    },
    {
        "name": "18LF2431",
        "clock": 4
    },
    {
        "name": "18LF2439",
        "clock": 20
    },
    {
        "name": "18LF2450",
        "clock": 4
    },
    {
        "name": "18LF2455",
        "clock": 4
    },
    {
        "name": "18LF2458",
        "clock": 4
    },
    {
        "name": "18LF248",
        "clock": 20
    },
    {
        "name": "18LF2480",
        "clock": 4
    },
    {
        "name": "18LF24J10",
        "clock": 4
    },
    {
        "name": "18LF24J11",
        "clock": 4
    },
    {
        "name": "18LF24J50",
        "clock": 4
    },
    {
        "name": "18LF24K22",
        "clock": 4
    },
    {
        "name": "18LF24K40",
        "clock": 1
    },
    {
        "name": "18LF24K42",
        "clock": 1
    },
    {
        "name": "18LF24K50",
        "clock": 4
    },
    {
        "name": "18LF2510",
        "clock": 4
    },
    {
        "name": "18LF2515",
        "clock": 4
    },
    {
        "name": "18LF252",
        "clock": 20
    },
    {
        "name": "18LF2520",
        "clock": 4
    },
    {
        "name": "18LF2523",
        "clock": 4
    },
    {
        "name": "18LF2525",
        "clock": 4
    },
    {
        "name": "18LF2539",
        "clock": 20
    },
    {
        "name": "18LF2550",
        "clock": 4
    },
    {
        "name": "18LF2553",
        "clock": 4
    },
    {
        "name": "18LF258",
        "clock": 20
    },
    {
        "name": "18LF2580",
        "clock": 4
    },
    {
        "name": "18LF2585",
        "clock": 4
    },
    {
        "name": "18LF25J10",
        "clock": 4
    },
    {
        "name": "18LF25J11",
        "clock": 4
    },
    {
        "name": "18LF25J50",
        "clock": 4
    },
    {
        "name": "18LF25K22",
        "clock": 4
    },
    {
        "name": "18LF25K40",
        "clock": 1
    },
    {
        "name": "18LF25K42",
        "clock": 1
    },
    {
        "name": "18LF25K50",
        "clock": 4
    },
    {
        "name": "18LF25K80",
        "clock": 4
    },
    {
        "name": "18LF25K83",
        "clock": 1
    },
    {
        "name": "18LF2610",
        "clock": 4
    },
    {
        "name": "18LF2620",
        "clock": 4
    },
    {
        "name": "18LF2680",
        "clock": 4
    },
    {
        "name": "18LF2682",
        "clock": 4
    },
    {
        "name": "18LF2685",
        "clock": 4
    },
    {
        "name": "18LF26J11",
        "clock": 4
    },
    {
        "name": "18LF26J13",
        "clock": 4
    },
    {
        "name": "18LF26J50",
        "clock": 4
    },
    {
        "name": "18LF26J53",
        "clock": 4
    },
    {
        "name": "18LF26K22",
        "clock": 4
    },
    {
        "name": "18LF26K40",
        "clock": 1
    },
    {
        "name": "18LF26K42",
        "clock": 1
    },
    {
        "name": "18LF26K80",
        "clock": 4
    },
    {
        "name": "18LF26K83",
        "clock": 1
    },
    {
        "name": "18LF27J13",
        "clock": 4
    },
    {
        "name": "18LF27J53",
        "clock": 4
    },
    {
        "name": "18LF27K40",
        "clock": 1
    },
    {
        "name": "18LF27K42",
        "clock": 1
    },
    {
        "name": "18LF4220",
        "clock": 4
    },
    {
        "name": "18LF4221",
        "clock": 4
    },
    {
        "name": "18LF4320",
        "clock": 4
    },
    {
        "name": "18LF4321",
        "clock": 4
    },
    {
        "name": "18LF4331",
        "clock": 4
    },
    {
        "name": "18LF43K22",
        "clock": 4
    },
    {
        "name": "18LF4410",
        "clock": 4
    },
    {
        "name": "18LF442",
        "clock": 20
    },
    {
        "name": "18LF4420",
        "clock": 4
    },
    {
        "name": "18LF4423",
        "clock": 4
    },
    {
        "name": "18LF4431",
        "clock": 4
    },
    {
        "name": "18LF4439",
        "clock": 20
    },
    {
        "name": "18LF4450",
        "clock": 4
    },
    {
        "name": "18LF4455",
        "clock": 4
    },
    {
        "name": "18LF4458",
        "clock": 4
    },
    {
        "name": "18LF448",
        "clock": 20
    },
    {
        "name": "18LF4480",
        "clock": 4
    },
    {
        "name": "18LF44J10",
        "clock": 4
    },
    {
        "name": "18LF44J11",
        "clock": 4
    },
    {
        "name": "18LF44J50",
        "clock": 4
    },
    {
        "name": "18LF44K22",
        "clock": 4
    },
    {
        "name": "18LF4510",
        "clock": 4
    },
    {
        "name": "18LF4515",
        "clock": 4
    },
    {
        "name": "18LF452",
        "clock": 20
    },
    {
        "name": "18LF4520",
        "clock": 4
    },
    {
        "name": "18LF4523",
        "clock": 4
    },
    {
        "name": "18LF4525",
        "clock": 4
    },
    {
        "name": "18LF4539",
        "clock": 20
    },
    {
        "name": "18LF4550",
        "clock": 4
    },
    {
        "name": "18LF4553",
        "clock": 4
    },
    {
        "name": "18LF458",
        "clock": 20
    },
    {
        "name": "18LF4580",
        "clock": 4
    },
    {
        "name": "18LF4585",
        "clock": 4
    },
    {
        "name": "18LF45J10",
        "clock": 4
    },
    {
        "name": "18LF45J11",
        "clock": 4
    },
    {
        "name": "18LF45J50",
        "clock": 4
    },
    {
        "name": "18LF45K22",
        "clock": 4
    },
    {
        "name": "18LF45K40",
        "clock": 1
    },
    {
        "name": "18LF45K42",
        "clock": 1
    },
    {
        "name": "18LF45K50",
        "clock": 4
    },
    {
        "name": "18LF45K80",
        "clock": 4
    },
    {
        "name": "18LF4610",
        "clock": 4
    },
    {
        "name": "18LF4620",
        "clock": 4
    },
    {
        "name": "18LF4680",
        "clock": 4
    },
    {
        "name": "18LF4682",
        "clock": 4
    },
    {
        "name": "18LF4685",
        "clock": 4
    },
    {
        "name": "18LF46J11",
        "clock": 4
    },
    {
        "name": "18LF46J13",
        "clock": 4
    },
    {
        "name": "18LF46J50",
        "clock": 4
    },
    {
        "name": "18LF46J53",
        "clock": 4
    },
    {
        "name": "18LF46K22",
        "clock": 4
    },
    {
        "name": "18LF46K40",
        "clock": 1
    },
    {
        "name": "18LF46K42",
        "clock": 1
    },
    {
        "name": "18LF46K80",
        "clock": 4
    },
    {
        "name": "18LF47J13",
        "clock": 4
    },
    {
        "name": "18LF47J53",
        "clock": 4
    },
    {
        "name": "18LF47K40",
        "clock": 1
    },
    {
        "name": "18LF47K42",
        "clock": 1
    },
    {
        "name": "18LF55K42",
        "clock": 1
    },
    {
        "name": "18LF56K42",
        "clock": 1
    },
    {
        "name": "18LF57K42",
        "clock": 1
    },
    {
        "name": "18LF6310",
        "clock": 4
    },
    {
        "name": "18LF6390",
        "clock": 4
    },
    {
        "name": "18LF6393",
        "clock": 4
    },
    {
        "name": "18LF6410",
        "clock": 4
    },
    {
        "name": "18LF6490",
        "clock": 4
    },
    {
        "name": "18LF6493",
        "clock": 4
    },
    {
        "name": "18LF6520",
        "clock": 20
    },
    {
        "name": "18LF6525",
        "clock": 20
    },
    {
        "name": "18LF6527",
        "clock": 4
    },
    {
        "name": "18LF6585",
        "clock": 20
    },
    {
        "name": "18LF65K40",
        "clock": 1
    },
    {
        "name": "18LF65K80",
        "clock": 4
    },
    {
        "name": "18LF6620",
        "clock": 20
    },
    {
        "name": "18LF6621",
        "clock": 20
    },
    {
        "name": "18LF6622",
        "clock": 4
    },
    {
        "name": "18LF6627",
        "clock": 4
    },
    {
        "name": "18LF6628",
        "clock": 4
    },
    {
        "name": "18LF6680",
        "clock": 4
    },
    {
        "name": "18LF66K40",
        "clock": 1
    },
    {
        "name": "18LF66K80",
        "clock": 4
    },
    {
        "name": "18LF6720",
        "clock": 20
    },
    {
        "name": "18LF6722",
        "clock": 4
    },
    {
        "name": "18LF6723",
        "clock": 4
    },
    {
        "name": "18LF67K40",
        "clock": 1
    },
    {
        "name": "18LF8310",
        "clock": 4
    },
    {
        "name": "18LF8390",
        "clock": 4
    },
    {
        "name": "18LF8393",
        "clock": 4
    },
    {
        "name": "18LF8410",
        "clock": 4
    },
    {
        "name": "18LF8490",
        "clock": 4
    },
    {
        "name": "18LF8493",
        "clock": 4
    },
    {
        "name": "18LF8520",
        "clock": 20
    },
    {
        "name": "18LF8525",
        "clock": 20
    },
    {
        "name": "18LF8527",
        "clock": 4
    },
    {
        "name": "18LF8585",
        "clock": 20
    },
    {
        "name": "18LF8620",
        "clock": 20
    },
    {
        "name": "18LF8621",
        "clock": 20
    },
    {
        "name": "18LF8622",
        "clock": 4
    },
    {
        "name": "18LF8627",
        "clock": 4
    },
    {
        "name": "18LF8628",
        "clock": 4
    },
    {
        "name": "18LF8680",
        "clock": 4
    },
    {
        "name": "18LF8720",
        "clock": 20
    },
    {
        "name": "18LF8722",
        "clock": 4
    },
    {
        "name": "18LF8723",
        "clock": 4
    },
    {
        "name": "18MACRO",
        "clock": 4
    },
    {
        "name": "AVR128DA28",
        "clock": 20
    },
    {
        "name": "AVR128DA32",
        "clock": 20
    },
    {
        "name": "AVR128DA48",
        "clock": 20
    },
    {
        "name": "AVR128DA64",
        "clock": 20
    },
    {
        "name": "AVR128DB28",
        "clock": 20
    },
    {
        "name": "AVR128DB32",
        "clock": 20
    },
    {
        "name": "AVR128DB48",
        "clock": 20
    },
    {
        "name": "AVR128DB64",
        "clock": 20
    },
    {
        "name": "AVR16DD14",
        "clock": 20
    },
    {
        "name": "AVR16DD20",
        "clock": 20
    },
    {
        "name": "AVR16DD28",
        "clock": 20
    },
    {
        "name": "AVR16DD32",
        "clock": 20
    },
    {
        "name": "AVR32DA28",
        "clock": 20
    },
    {
        "name": "AVR32DA32",
        "clock": 20
    },
    {
        "name": "AVR32DA48",
        "clock": 20
    },
    {
        "name": "AVR32DB28",
        "clock": 20
    },
    {
        "name": "AVR32DB32",
        "clock": 20
    },
    {
        "name": "AVR32DB48",
        "clock": 20
    },
    {
        "name": "AVR32DD14",
        "clock": 20
    },
    {
        "name": "AVR32DD20",
        "clock": 20
    },
    {
        "name": "AVR32DD28",
        "clock": 20
    },
    {
        "name": "AVR32DD32",
        "clock": 20
    },
    {
        "name": "AVR64DA28",
        "clock": 20
    },
    {
        "name": "AVR64DA32",
        "clock": 20
    },
    {
        "name": "AVR64DA48",
        "clock": 20
    },
    {
        "name": "AVR64DA64",
        "clock": 20
    },
    {
        "name": "AVR64DB28",
        "clock": 20
    },
    {
        "name": "AVR64DB32",
        "clock": 20
    },
    {
        "name": "AVR64DB48",
        "clock": 20
    },
    {
        "name": "AVR64DB64",
        "clock": 20
    },
    {
        "name": "AVR64DD14",
        "clock": 20
    },
    {
        "name": "AVR64DD20",
        "clock": 20
    },
    {
        "name": "AVR64DD28",
        "clock": 20
    },
    {
        "name": "AVR64DD32",
        "clock": 20
    },
    {
        "name": "MEGA103",
        "clock": 16
    },
    {
        "name": "MEGA128",
        "clock": 16
    },
    {
        "name": "MEGA1280",
        "clock": 16
    },
    {
        "name": "MEGA1281",
        "clock": 16
    },
    {
        "name": "MEGA1284",
        "clock": 16
    },
    {
        "name": "MEGA1284P",
        "clock": 16
    },
    {
        "name": "MEGA1284RFR2",
        "clock": 16
    },
    {
        "name": "MEGA128A",
        "clock": 16
    },
    {
        "name": "MEGA128RFA1",
        "clock": 16
    },
    {
        "name": "MEGA128RFR2",
        "clock": 16
    },
    {
        "name": "MEGA16",
        "clock": 16
    },
    {
        "name": "MEGA1608",
        "clock": 20
    },
    {
        "name": "MEGA1609",
        "clock": 20
    },
    {
        "name": "MEGA161",
        "clock": 16
    },
    {
        "name": "MEGA162",
        "clock": 16
    },
    {
        "name": "MEGA163",
        "clock": 16
    },
    {
        "name": "MEGA164A",
        "clock": 16
    },
    {
        "name": "MEGA164P",
        "clock": 16
    },
    {
        "name": "MEGA164PA",
        "clock": 16
    },
    {
        "name": "MEGA165",
        "clock": 16
    },
    {
        "name": "MEGA165A",
        "clock": 16
    },
    {
        "name": "MEGA165P",
        "clock": 16
    },
    {
        "name": "MEGA165PA",
        "clock": 16
    },
    {
        "name": "MEGA168",
        "clock": 16
    },
    {
        "name": "MEGA168A",
        "clock": 16
    },
    {
        "name": "MEGA168P",
        "clock": 16
    },
    {
        "name": "MEGA168PA",
        "clock": 16
    },
    {
        "name": "MEGA168PB",
        "clock": 16
    },
    {
        "name": "MEGA169",
        "clock": 16
    },
    {
        "name": "MEGA169A",
        "clock": 16
    },
    {
        "name": "MEGA169P",
        "clock": 16
    },
    {
        "name": "MEGA169PA",
        "clock": 16
    },
    {
        "name": "MEGA16A",
        "clock": 16
    },
    {
        "name": "MEGA16HVA",
        "clock": 16
    },
    {
        "name": "MEGA16HVB",
        "clock": 16
    },
    {
        "name": "MEGA16HVBREVB",
        "clock": 16
    },
    {
        "name": "MEGA16M1",
        "clock": 16
    },
    {
        "name": "MEGA16U2",
        "clock": 16
    },
    {
        "name": "MEGA16U4",
        "clock": 16
    },
    {
        "name": "MEGA2560",
        "clock": 16
    },
    {
        "name": "MEGA2561",
        "clock": 16
    },
    {
        "name": "MEGA2564RFR2",
        "clock": 16
    },
    {
        "name": "MEGA256RFR2",
        "clock": 16
    },
    {
        "name": "MEGA32",
        "clock": 16
    },
    {
        "name": "MEGA3208",
        "clock": 20
    },
    {
        "name": "MEGA3209",
        "clock": 20
    },
    {
        "name": "MEGA323",
        "clock": 16
    },
    {
        "name": "MEGA324A",
        "clock": 16
    },
    {
        "name": "MEGA324P",
        "clock": 16
    },
    {
        "name": "MEGA324PA",
        "clock": 16
    },
    {
        "name": "MEGA325",
        "clock": 16
    },
    {
        "name": "MEGA3250",
        "clock": 16
    },
    {
        "name": "MEGA3250A",
        "clock": 16
    },
    {
        "name": "MEGA3250P",
        "clock": 16
    },
    {
        "name": "MEGA3250PA",
        "clock": 16
    },
    {
        "name": "MEGA325A",
        "clock": 16
    },
    {
        "name": "MEGA325P",
        "clock": 16
    },
    {
        "name": "MEGA325PA",
        "clock": 16
    },
    {
        "name": "MEGA328",
        "clock": 16
    },
    {
        "name": "MEGA328P",
        "clock": 16
    },
    {
        "name": "MEGA328PB",
        "clock": 16
    },
    {
        "name": "MEGA329",
        "clock": 16
    },
    {
        "name": "MEGA3290",
        "clock": 16
    },
    {
        "name": "MEGA3290A",
        "clock": 16
    },
    {
        "name": "MEGA3290P",
        "clock": 16
    },
    {
        "name": "MEGA3290PA",
        "clock": 16
    },
    {
        "name": "MEGA329A",
        "clock": 16
    },
    {
        "name": "MEGA329P",
        "clock": 16
    },
    {
        "name": "MEGA329PA",
        "clock": 16
    },
    {
        "name": "MEGA32A",
        "clock": 16
    },
    {
        "name": "MEGA32C1",
        "clock": 16
    },
    {
        "name": "MEGA32HVB",
        "clock": 16
    },
    {
        "name": "MEGA32HVBREVB",
        "clock": 16
    },
    {
        "name": "MEGA32M1",
        "clock": 16
    },
    {
        "name": "MEGA32U2",
        "clock": 16
    },
    {
        "name": "MEGA32U4",
        "clock": 16
    },
    {
        "name": "MEGA32U6",
        "clock": 16
    },
    {
        "name": "MEGA406",
        "clock": 16
    },
    {
        "name": "MEGA48",
        "clock": 16
    },
    {
        "name": "MEGA4808",
        "clock": 20
    },
    {
        "name": "MEGA4809",
        "clock": 20
    },
    {
        "name": "MEGA48A",
        "clock": 16
    },
    {
        "name": "MEGA48P",
        "clock": 16
    },
    {
        "name": "MEGA48PA",
        "clock": 16
    },
    {
        "name": "MEGA48PB",
        "clock": 16
    },
    {
        "name": "MEGA64",
        "clock": 16
    },
    {
        "name": "MEGA640",
        "clock": 16
    },
    {
        "name": "MEGA644",
        "clock": 16
    },
    {
        "name": "MEGA644A",
        "clock": 16
    },
    {
        "name": "MEGA644P",
        "clock": 16
    },
    {
        "name": "MEGA644PA",
        "clock": 16
    },
    {
        "name": "MEGA644RFR2",
        "clock": 16
    },
    {
        "name": "MEGA645",
        "clock": 16
    },
    {
        "name": "MEGA6450",
        "clock": 16
    },
    {
        "name": "MEGA6450A",
        "clock": 16
    },
    {
        "name": "MEGA6450P",
        "clock": 16
    },
    {
        "name": "MEGA645A",
        "clock": 16
    },
    {
        "name": "MEGA645P",
        "clock": 16
    },
    {
        "name": "MEGA649",
        "clock": 16
    },
    {
        "name": "MEGA6490",
        "clock": 16
    },
    {
        "name": "MEGA6490A",
        "clock": 16
    },
    {
        "name": "MEGA6490P",
        "clock": 16
    },
    {
        "name": "MEGA649A",
        "clock": 16
    },
    {
        "name": "MEGA649P",
        "clock": 16
    },
    {
        "name": "MEGA64A",
        "clock": 16
    },
    {
        "name": "MEGA64C1",
        "clock": 16
    },
    {
        "name": "MEGA64HVE2",
        "clock": 16
    },
    {
        "name": "MEGA64M1",
        "clock": 16
    },
    {
        "name": "MEGA64RFR2",
        "clock": 16
    },
    {
        "name": "MEGA8",
        "clock": 16
    },
    {
        "name": "MEGA808",
        "clock": 20
    },
    {
        "name": "MEGA809",
        "clock": 20
    },
    {
        "name": "MEGA8515",
        "clock": 16
    },
    {
        "name": "MEGA8535",
        "clock": 16
    },
    {
        "name": "MEGA88",
        "clock": 16
    },
    {
        "name": "MEGA88A",
        "clock": 16
    },
    {
        "name": "MEGA88P",
        "clock": 16
    },
    {
        "name": "MEGA88PA",
        "clock": 16
    },
    {
        "name": "MEGA88PB",
        "clock": 16
    },
    {
        "name": "MEGA8A",
        "clock": 16
    },
    {
        "name": "MEGA8HVA",
        "clock": 16
    },
    {
        "name": "MEGA8U2",
        "clock": 16
    },
    {
        "name": "TINY10",
        "clock": 8
    },
    {
        "name": "TINY102",
        "clock": 8
    },
    {
        "name": "TINY104",
        "clock": 8
    },
    {
        "name": "TINY11",
        "clock": 8
    },
    {
        "name": "TINY12",
        "clock": 8
    },
    {
        "name": "TINY13",
        "clock": 8
    },
    {
        "name": "TINY13A",
        "clock": 8
    },
    {
        "name": "TINY15",
        "clock": 8
    },
    {
        "name": "TINY1604",
        "clock": 20
    },
    {
        "name": "TINY1606",
        "clock": 20
    },
    {
        "name": "TINY1607",
        "clock": 20
    },
    {
        "name": "TINY1614",
        "clock": 20
    },
    {
        "name": "TINY1616",
        "clock": 20
    },
    {
        "name": "TINY1617",
        "clock": 20
    },
    {
        "name": "TINY1624",
        "clock": 20
    },
    {
        "name": "TINY1626",
        "clock": 20
    },
    {
        "name": "TINY1627",
        "clock": 20
    },
    {
        "name": "TINY1634",
        "clock": 8
    },
    {
        "name": "TINY167",
        "clock": 8
    },
    {
        "name": "TINY20",
        "clock": 8
    },
    {
        "name": "TINY202",
        "clock": 20
    },
    {
        "name": "TINY204",
        "clock": 20
    },
    {
        "name": "TINY212",
        "clock": 20
    },
    {
        "name": "TINY214",
        "clock": 20
    },
    {
        "name": "TINY22",
        "clock": 8
    },
    {
        "name": "TINY2313",
        "clock": 8
    },
    {
        "name": "TINY2313A",
        "clock": 8
    },
    {
        "name": "TINY24",
        "clock": 8
    },
    {
        "name": "TINY24A",
        "clock": 8
    },
    {
        "name": "TINY25",
        "clock": 8
    },
    {
        "name": "TINY26",
        "clock": 8
    },
    {
        "name": "TINY261",
        "clock": 8
    },
    {
        "name": "TINY261A",
        "clock": 8
    },
    {
        "name": "TINY28",
        "clock": 8
    },
    {
        "name": "TINY3216",
        "clock": 20
    },
    {
        "name": "TINY3217",
        "clock": 20
    },
    {
        "name": "TINY3217_16",
        "clock": 20
    },
    {
        "name": "TINY3217_20",
        "clock": 20
    },
    {
        "name": "TINY3224",
        "clock": 20
    },
    {
        "name": "TINY3226",
        "clock": 20
    },
    {
        "name": "TINY3227",
        "clock": 20
    },
    {
        "name": "TINY4",
        "clock": 8
    },
    {
        "name": "TINY40",
        "clock": 8
    },
    {
        "name": "TINY402",
        "clock": 20
    },
    {
        "name": "TINY404",
        "clock": 20
    },
    {
        "name": "TINY406",
        "clock": 20
    },
    {
        "name": "TINY412",
        "clock": 20
    },
    {
        "name": "TINY414",
        "clock": 20
    },
    {
        "name": "TINY416",
        "clock": 20
    },
    {
        "name": "TINY417",
        "clock": 20
    },
    {
        "name": "TINY424",
        "clock": 20
    },
    {
        "name": "TINY426",
        "clock": 20
    },
    {
        "name": "TINY427",
        "clock": 20
    },
    {
        "name": "TINY4313",
        "clock": 8
    },
    {
        "name": "TINY43U",
        "clock": 8
    },
    {
        "name": "TINY44",
        "clock": 8
    },
    {
        "name": "TINY441",
        "clock": 8
    },
    {
        "name": "TINY44A",
        "clock": 8
    },
    {
        "name": "TINY45",
        "clock": 8
    },
    {
        "name": "TINY461",
        "clock": 8
    },
    {
        "name": "TINY461A",
        "clock": 8
    },
    {
        "name": "TINY48",
        "clock": 8
    },
    {
        "name": "TINY5",
        "clock": 8
    },
    {
        "name": "TINY804",
        "clock": 20
    },
    {
        "name": "TINY806",
        "clock": 20
    },
    {
        "name": "TINY807",
        "clock": 20
    },
    {
        "name": "TINY814",
        "clock": 20
    },
    {
        "name": "TINY816",
        "clock": 20
    },
    {
        "name": "TINY817",
        "clock": 20
    },
    {
        "name": "TINY824",
        "clock": 20
    },
    {
        "name": "TINY826",
        "clock": 20
    },
    {
        "name": "TINY827",
        "clock": 20
    },
    {
        "name": "TINY828",
        "clock": 8
    },
    {
        "name": "TINY84",
        "clock": 8
    },
    {
        "name": "TINY841",
        "clock": 8
    },
    {
        "name": "TINY84A",
        "clock": 8
    },
    {
        "name": "TINY85",
        "clock": 8
    },
    {
        "name": "TINY861",
        "clock": 8
    },
    {
        "name": "TINY861A",
        "clock": 8
    },
    {
        "name": "TINY87",
        "clock": 8
    },
    {
        "name": "TINY88",
        "clock": 8
    },
    {
        "name": "TINY9",
        "clock": 8
    }
];

        function logToWebPageErrors(message, messageType = "INFO") {
            var errorDiv = document.getElementById("WebPageErrors");
            if (!errorDiv) {
                console.error("Error: WebPageErrors div not found!");
                return;
            }
            var newMessage = document.createElement("span");
            newMessage.style.fontFamily = "monospace";
            switch (messageType.toUpperCase()) {
                case "WARNING":
                    newMessage.style.color = "green";
                    break;
                case "ERROR":
                    console.error(`Writing to webpage errors [${messageType}]:`, message);
                    newMessage.style.color = "red";
                    break;
                case "INFO":
                default:
                    newMessage.style.color = "black";
                    break;
            }
            // Ensure the last character is \n if not already present
            let formattedMessage = String(message);
            if (formattedMessage.charAt(formattedMessage.length - 1) !== '\n') {
                formattedMessage += '\n';
            }
            newMessage.innerHTML = formattedMessage.replace(/\r?\n/g, "<br>");
            errorDiv.appendChild(newMessage);
            errorDiv.style.display = "block";
            errorDiv.scrollTop = errorDiv.scrollHeight;
        }

        function logToWebpageConsole(message, messageType = "INFO") {
            var consoleDiv = document.getElementById("webpageconsole");
            if (!consoleDiv) {
                console.error("Error: Webpage console div not found!");
                logToWebPageErrors("Error: Webpage console div not found!\n", "ERROR");
                return;
            }
            var newMessage = document.createElement("span");
            newMessage.style.fontFamily = "monospace";
            newMessage.style.color = "black";
            // Ensure the last character is \n if not already present
            let formattedMessage = String(message);
            if (formattedMessage.charAt(formattedMessage.length - 1) !== '\n') {
                formattedMessage += '\n';
            }
            newMessage.innerHTML = formattedMessage.replace(/\r?\n/g, "<br>");
            consoleDiv.appendChild(newMessage);
            consoleDiv.style.display = "block";
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        }

        document.addEventListener("DOMContentLoaded", function () {
            fetch('changelog.txt')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}. Ensure changelog.txt is next to HTML and server allows access.`);
                    }
                    return response.text();
                })
                .then(text => {
                    // Find the first occurrence of "# Version" and extract the version number
                    const versionMatch = text.match(/^# Version\s+(.*)$/m);
                    if (!versionMatch) {
                        console.warn("No version found in changelog.txt");
                        return;
                    }

                    const currentVersion = versionMatch[1].trim(); // Extracted version
                    const lastVersion = localStorage.getItem("lastVersion");

                    if (currentVersion !== lastVersion) {
                        showPopup(text); // Display formatted changelog
                        localStorage.setItem("lastVersion", currentVersion); // Store new version
                    } else {
                        //console.log("Changelog version matches last seen version:", currentVersion);
                    }
                })
                .catch(error => {
                    console.error("Failed to fetch changelog.txt:", error.message);
                });
        });

        function showPopup(markdownText) {
            const popup = document.createElement("div");
            popup.style.position = "fixed";
            popup.style.top = "10px";
            popup.style.left = "50%";
            popup.style.transform = "translateX(-50%)";
            popup.style.width = "60%";
            popup.style.maxWidth = "800px";
            popup.style.height = "auto";
            popup.style.padding = "20px";
            popup.style.background = "white";
            popup.style.border = "2px solid black";
            popup.style.boxShadow = "0px 4px 8px rgba(0, 0, 0, 0.2)";
            popup.style.overflowY = "auto"; // Enables vertical scrolling
            popup.style.maxHeight = "480px"; // Limits height, ensuring scrollability
            popup.style.zIndex = "1000";

            // Convert Markdown to HTML using Marked.js
            const contentDiv = document.createElement("div");
            contentDiv.innerHTML = marked.parse(markdownText);
            popup.appendChild(contentDiv);

            // Create and position OK button at the top-right
            const okButton = document.createElement("button");
            okButton.textContent = "OK";
            okButton.style.position = "absolute";
            okButton.style.top = "10px";
            okButton.style.right = "10px";
            okButton.style.padding = "5px 10px";
            okButton.style.background = "#007bff";
            okButton.style.color = "white";
            okButton.style.border = "none";
            okButton.style.cursor = "pointer";
            okButton.style.display = "none"; // Initially hidden

            okButton.onclick = () => document.body.removeChild(popup);
            popup.appendChild(okButton);

            document.body.appendChild(popup);

            // Show OK button after 5 seconds
            setTimeout(() => {
                okButton.style.display = "block";
            }, 5000);
        }

        // Add new function to handle Readme popup
        function showPopupFromReadme() {
            fetch('changelog.txt')
                .then(response => {
                    if (!response.ok) {
                        console.warn("changelog.txt not found, falling back to changelog.txt");
                        return fetch('changelog.txt').then(changelogResponse => {
                            if (!changelogResponse.ok) throw new Error("Changelog.txt also not found");
                            return changelogResponse.text();
                        });
                    }
                    return response.text();
                })
                .then(text => {
                    showPopup(text); // Display the fetched Markdown content
                })
                .catch(error => {
                    console.error("Failed to fetch README.md or changelog.txt:", error.message);
                    logToWebPageErrors(`Error: Could not load Readme or changelog: ${error.message}\n`, "ERROR");
                });
        }

    </script>
</body>
</html>